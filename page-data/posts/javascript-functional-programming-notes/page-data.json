{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/javascript-functional-programming-notes/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>本文为 <a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/cotent/\">JS 函数式编程指南</a>  笔记</p>\n</blockquote>\n<h2>函数是一等公民</h2>\n<p>当我们说函数是“一等公民”的时候，我们实际上说的是它们跟其他对象都一样，你可以像对待其他数据结构一样对待它们。</p>\n<h2>纯函数</h2>\n<p>相同的输入产生相同的输出，并且没有副作用，即为纯函数。例如 <code>Array.prototype.slice</code> 是纯函数，而 <code>Array.prototype.splice</code> 不是纯函数。</p>\n<p>只要函数跟外界环境发生交互，就是有副作用。但并不是说要禁止副作用，函数式的编程哲学是假定副作用是造成不正当行为的主要原因。</p>\n<!--more-->\n<p>纯函数的好处：</p>\n<ul>\n<li>可缓存性 Cacheable</li>\n<li>可移植性 Portable</li>\n<li>可测试性 Testable</li>\n<li>合理性 Reasonable (引用透明)</li>\n</ul>\n<h2>柯里化</h2>\n<p>只传递一个参数来调用它，然后返回另一个函数处理剩下的参数，称为柯离化，也叫做局部调用。</p>\n<pre><code class=\"language-js\">const _ = require('lodash/fp')\n\nconst add = _.curry((a, b) => a + b)\n\nconst add2 = add(2)\n\nadd2(3) // 5\n</code></pre>\n<h2>组合</h2>\n<p>通过组合两个或多个函数返回一个新的函数，例如:</p>\n<pre><code class=\"language-js\">const g = n => n + 1;\nconst f = n => n * 2;\n\nconst fn = compomse(f, g);\n\nfn(1); // => f(g(1)) => 4\n</code></pre>\n<p>在 compomse 中，g 将先于 f 执行，因此创建了一个从右到左的数据流。</p>\n<p><em>结合律：compomse(f, compomse(g, h)) 等同于 compomse(compomse(f, g), h)</em></p>\n<h2>pointfree</h2>\n<pre><code>“Love means never having to say you're sorry”\n</code></pre>\n<p>pointfree 模式是指永远不需要声明数据。</p>\n<p>以一个不恰当的代码比喻：</p>\n<pre><code class=\"language-js\">const hello = name => console.log(`hello ${name}`);\n\n// not pointfree\nconst sayHello = (name) => {\n  return hello(name);\n}\n\n// pointfree\nconst sayHello = hello\n</code></pre>\n<p>PS: 个人理解，pointfree 即是指函数仅只是其他函数的组合，并不需要指定外部的数据，函数中也不需要传入外部变量。\n但这无法绝对避免，例如获取某个时间字符串的时间戳：<code>const timestamp = (date) => (new Date(date)).getTime()</code>。</p>\n<h2>debug</h2>\n<p>在函数的组合中需要进行 debug 的话，可以使用 <code>trace</code> 函数。</p>\n<pre><code class=\"language-js\">  const trace = curry((tag, value) => {\n    console.log(tag, value);\n    return value;\n  });\n</code></pre>\n<p>将 <code>trace</code> 函数插入到 <code>compomse</code> 中即可检查上一个函数返回值是否正确。</p>\n<h2>identity</h2>\n<p>范畴学中独特的态射，这个函数接受随便什么东西，然后原封不动的吐出来。一个假装自己是普通数据的函数。</p>\n<pre><code class=\"language-js\">const identity = x => x;\n</code></pre>\n<p>identity 函数可以一起使用，但是看起来好像是没有卵用：</p>\n<pre><code class=\"language-js\">compomse(identity, f) == compomse(f, identity) == f\n</code></pre>\n<h2>类型签名</h2>\n<p>接受具体类型，返回具体类型：</p>\n<pre><code class=\"language-js\">// hello::String -> String\nconst hello = name => `hello ${name}`;\n</code></pre>\n<p>接受任意类型，并返回相同类型：</p>\n<pre><code class=\"language-js\">// identity::a -> a\nconst identity = n => n\n</code></pre>\n<p>接受函数参数：</p>\n<pre><code class=\"language-js\">// map::(a -> b) -> ![pic](a) -> ![pic](b)\nconst map = curry((f, xs) => xs.map(f));\n</code></pre>\n<h3>类型约束</h3>\n<pre><code class=\"language-js\">// sort::Ord a => ![pic](a) => ![pic](a)\nconst sort = balabala\n</code></pre>\n<p>胖箭头的左边表明 a 一定是一个 Ord 对象，也就是说 a 必须要实现 Ord 接口（可排序）。</p>\n<p>通过这种方式能够限制函数的作用范围，这种接口声明叫做类型约束。</p>\n<h2>functor</h2>\n<pre><code class=\"language-js\">const Functor = (x) => {\n  this.__value = x;\n};\n\nFunctor.of = x => new Functor(x);\n\nFunctor.prototype.map = f => Functor.of(f(this.__value));\n</code></pre>\n<p>functor 是实现了 <code>map</code> 函数，并遵守某些特点规则的容器类型，具有 <code>mappable</code> 的特点（类似于 Promise 的 thenable）。</p>\n<h3>Maybe</h3>\n<p>Maybe 是另一种 functor，实际上只是多了空值检查。</p>\n<pre><code class=\"language-js\">const Maybe = (x) => {\n  this.__value = x;\n};\n\nMaybe.of = x => new Maybe(x);\n\nMaybe.prototype.isNothing = () => this.__value === null || this.__value === undefined;\n\nMaybe.prototype.map = f => this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));\n</code></pre>\n<p>Maybe 使得在 <code>map</code> 调用中产生 null 或者 undefined 时不会爆出错误，而是最后返回 <code>Maybe.of(null)</code>。</p>\n<h3>Either</h3>\n<p>Either 又是另外一种 functor, 不同于正常的 functor, Either 不管怎么 map 都不会改变自己的值。</p>\n<pre><code class=\"language-js\">const Either = (x) => {\n  this.__value = x;\n};\n\nEither.of = x => new Either(x);\n\nEither.prototype.map = () => this;\n</code></pre>\n<p>Either 用于错误处理，当出现错误时我们返回一个 <code>Either.of(error)</code>, 它将把错误带到最后，并显示出来。\n实际上它就是一个错误消息的 functor, 只是指不会被改变。</p>\n<h3>IO</h3>\n<p>IO 又又是另外一种 functor, 与最普通的 functor 的差别是，IO 的 <code>__value</code> 是一个函数（不过，我们把它当成是数据）。</p>\n<pre><code class=\"language-js\">const IO = (f) => {\n  this.unsafaPerfromIO = f;\n};\n\nIO.of = x => new IO(() => x);\n\nIO.prototype.map = f => IO.of(compomse(f, this.unsafaPerfromIO));\n</code></pre>\n<p>IO 把非纯的动作捕获到包裹函数中，延迟执行非纯的动作。并且，假装 IO 的返回指不是包裹函数本身，而是包裹函数执行后的返回值。</p>\n<p>当需要获取 IO 的值的时候，就执行 <code>IO.unsafaPerfromIO()</code>（此时才会执行整个过程 map by map）。</p>\n<h2>Monad</h2>\n<p>  pointed functor 是指实现了 <code>of</code> 方法的 functor</p>\n<p>  monad 是可以变扁的 pointed functor</p>\n<p>monad 主要的使用场景是用来解决嵌套的 functor。</p>\n<p>一个 functor，只要它定义了一个 <code>join</code> 方法和 <code>of</code> 方法，并遵守一些定律，那么它就是一个 monad。</p>\n<pre><code class=\"language-js\">const getItem = key => IO.of(() => localStorage.getItem(key));\n\nconst log = x = IO.of(() => {\n  console.log(x);\n  return x;\n});\n\nconst printItem = compomse(join, map(log), getItem);\n\nprintItem('xxx').unsafaPerfromIO();\n</code></pre>\n<h3>chain 函数</h3>\n<p>chain 函数是 functor map 之后 join 的抽象行为</p>\n<pre><code class=\"language-js\">const chain = curry((f, m) => m.map(f).join());\n</code></pre>\n<p>PS: 其实没有啥用，只是把 <code>compomse(join, map(log), ...)</code> 变成了 <code>compomse(chain(log), ...)</code></p>\n<h2>Applicative Functor</h2>\n<p>applicative functor 能够以一种简明扼要的方式把一个 functor 的值应用到另外一个 functor 上。</p>\n<p>  applicative functor 是实现了 <code>ap</code> 方法的 pointed functor</p>\n<pre><code class=\"language-js\">// applicative\nFunctor.prototype.ap = other => other.map(this.__value);\n\n// Functor.of(add(2)).ap(Functor.of(3));\n</code></pre>\n<p><code>Functor.of(x).map(f)</code> 等价于 <code>Functor.of(f).ap(Functor.of(x))</code>。</p>\n<h3>lift</h3>\n<p>以 pointfree 的方式调用 applicative functor。</p>\n<pre><code class=\"language-js\">const liftA2 = curry((f, functor1, functor2) => functor1.map(f).ap(functor2));\n</code></pre>\n<h3>操作符</h3>\n<p>  haskell 中可以使用 <code>&#x3C;$></code> 表示 <code>map</code>, <code>&#x3C;*></code> 表示 <code>ap</code>。</p>\n<pre><code class=\"language-js\">Functor.of(2).map(add).ap(Functor.of(3));\n// map(add, Functor.of(2)).ap(Functor.of(3));\n</code></pre>\n<p>等同于：</p>\n<pre><code class=\"language-haskell\">add &#x3C;$> Functor 2 &#x3C;*> Functor 3\n</code></pre>\n<h2>定律</h2>\n<ul>\n<li>同一：<code>A.of(id).ap(v) == v</code></li>\n<li>同态：<code>A.of(f).ap(A.of(x)) == A.of(f(x))</code></li>\n<li>互换：<code>v.ap(A.of(x)) == A.of(f => f(x)).ap(x)</code></li>\n<li>组合：<code>A.of(compomse).ap(u).ap(v).ap(w) == u.ap(v.ap(w))</code></li>\n</ul>","rawMarkdownBody":"\n> 本文为 [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/cotent/)  笔记\n\n## 函数是一等公民\n当我们说函数是“一等公民”的时候，我们实际上说的是它们跟其他对象都一样，你可以像对待其他数据结构一样对待它们。\n\n## 纯函数\n相同的输入产生相同的输出，并且没有副作用，即为纯函数。例如 `Array.prototype.slice` 是纯函数，而 `Array.prototype.splice` 不是纯函数。\n\n只要函数跟外界环境发生交互，就是有副作用。但并不是说要禁止副作用，函数式的编程哲学是假定副作用是造成不正当行为的主要原因。\n\n<!--more-->\n\n纯函数的好处：\n- 可缓存性 Cacheable\n- 可移植性 Portable\n- 可测试性 Testable\n- 合理性 Reasonable (引用透明)\n\n## 柯里化\n只传递一个参数来调用它，然后返回另一个函数处理剩下的参数，称为柯离化，也叫做局部调用。\n\n```js\nconst _ = require('lodash/fp')\n\nconst add = _.curry((a, b) => a + b)\n\nconst add2 = add(2)\n\nadd2(3) // 5\n```\n\n## 组合\n通过组合两个或多个函数返回一个新的函数，例如:\n\n```js\nconst g = n => n + 1;\nconst f = n => n * 2;\n\nconst fn = compomse(f, g);\n\nfn(1); // => f(g(1)) => 4\n```\n\n在 compomse 中，g 将先于 f 执行，因此创建了一个从右到左的数据流。\n\n*结合律：compomse(f, compomse(g, h)) 等同于 compomse(compomse(f, g), h)*\n\n## pointfree\n    “Love means never having to say you're sorry”\n\npointfree 模式是指永远不需要声明数据。\n\n以一个不恰当的代码比喻：\n```js\nconst hello = name => console.log(`hello ${name}`);\n\n// not pointfree\nconst sayHello = (name) => {\n  return hello(name);\n}\n\n// pointfree\nconst sayHello = hello\n```\n\nPS: 个人理解，pointfree 即是指函数仅只是其他函数的组合，并不需要指定外部的数据，函数中也不需要传入外部变量。\n但这无法绝对避免，例如获取某个时间字符串的时间戳：`const timestamp = (date) => (new Date(date)).getTime()`。\n\n## debug\n在函数的组合中需要进行 debug 的话，可以使用 `trace` 函数。\n\n```js\n  const trace = curry((tag, value) => {\n    console.log(tag, value);\n    return value;\n  });\n```\n\n将 `trace` 函数插入到 `compomse` 中即可检查上一个函数返回值是否正确。\n\n## identity\n范畴学中独特的态射，这个函数接受随便什么东西，然后原封不动的吐出来。一个假装自己是普通数据的函数。\n\n```js\nconst identity = x => x;\n```\n\nidentity 函数可以一起使用，但是看起来好像是没有卵用：\n```js\ncompomse(identity, f) == compomse(f, identity) == f\n```\n\n## 类型签名\n\n接受具体类型，返回具体类型：\n```js\n// hello::String -> String\nconst hello = name => `hello ${name}`;\n```\n\n接受任意类型，并返回相同类型：\n```js\n// identity::a -> a\nconst identity = n => n\n```\n\n接受函数参数：\n```js\n// map::(a -> b) -> ![pic](a) -> ![pic](b)\nconst map = curry((f, xs) => xs.map(f));\n```\n\n### 类型约束\n```js\n// sort::Ord a => ![pic](a) => ![pic](a)\nconst sort = balabala\n```\n\n胖箭头的左边表明 a 一定是一个 Ord 对象，也就是说 a 必须要实现 Ord 接口（可排序）。\n\n通过这种方式能够限制函数的作用范围，这种接口声明叫做类型约束。\n\n## functor\n\n```js\nconst Functor = (x) => {\n  this.__value = x;\n};\n\nFunctor.of = x => new Functor(x);\n\nFunctor.prototype.map = f => Functor.of(f(this.__value));\n```\n\nfunctor 是实现了 `map` 函数，并遵守某些特点规则的容器类型，具有 `mappable` 的特点（类似于 Promise 的 thenable）。\n\n### Maybe\nMaybe 是另一种 functor，实际上只是多了空值检查。\n\n```js\nconst Maybe = (x) => {\n  this.__value = x;\n};\n\nMaybe.of = x => new Maybe(x);\n\nMaybe.prototype.isNothing = () => this.__value === null || this.__value === undefined;\n\nMaybe.prototype.map = f => this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));\n```\n\nMaybe 使得在 `map` 调用中产生 null 或者 undefined 时不会爆出错误，而是最后返回 `Maybe.of(null)`。\n\n### Either\nEither 又是另外一种 functor, 不同于正常的 functor, Either 不管怎么 map 都不会改变自己的值。\n\n```js\nconst Either = (x) => {\n  this.__value = x;\n};\n\nEither.of = x => new Either(x);\n\nEither.prototype.map = () => this;\n```\n\nEither 用于错误处理，当出现错误时我们返回一个 `Either.of(error)`, 它将把错误带到最后，并显示出来。\n实际上它就是一个错误消息的 functor, 只是指不会被改变。\n\n### IO\nIO 又又是另外一种 functor, 与最普通的 functor 的差别是，IO 的 `__value` 是一个函数（不过，我们把它当成是数据）。\n\n```js\nconst IO = (f) => {\n  this.unsafaPerfromIO = f;\n};\n\nIO.of = x => new IO(() => x);\n\nIO.prototype.map = f => IO.of(compomse(f, this.unsafaPerfromIO));\n```\n\nIO 把非纯的动作捕获到包裹函数中，延迟执行非纯的动作。并且，假装 IO 的返回指不是包裹函数本身，而是包裹函数执行后的返回值。\n\n当需要获取 IO 的值的时候，就执行 `IO.unsafaPerfromIO()`（此时才会执行整个过程 map by map）。\n\n## Monad\n  pointed functor 是指实现了 `of` 方法的 functor\n\n  monad 是可以变扁的 pointed functor\n\nmonad 主要的使用场景是用来解决嵌套的 functor。\n\n一个 functor，只要它定义了一个 `join` 方法和 `of` 方法，并遵守一些定律，那么它就是一个 monad。\n\n```js\nconst getItem = key => IO.of(() => localStorage.getItem(key));\n\nconst log = x = IO.of(() => {\n  console.log(x);\n  return x;\n});\n\nconst printItem = compomse(join, map(log), getItem);\n\nprintItem('xxx').unsafaPerfromIO();\n```\n\n### chain 函数\n\nchain 函数是 functor map 之后 join 的抽象行为\n```js\nconst chain = curry((f, m) => m.map(f).join());\n```\n\nPS: 其实没有啥用，只是把 `compomse(join, map(log), ...)` 变成了 `compomse(chain(log), ...)`\n\n## Applicative Functor\n\napplicative functor 能够以一种简明扼要的方式把一个 functor 的值应用到另外一个 functor 上。\n\n  applicative functor 是实现了 `ap` 方法的 pointed functor\n\n```js\n// applicative\nFunctor.prototype.ap = other => other.map(this.__value);\n\n// Functor.of(add(2)).ap(Functor.of(3));\n```\n\n`Functor.of(x).map(f)` 等价于 `Functor.of(f).ap(Functor.of(x))`。\n\n### lift\n\n以 pointfree 的方式调用 applicative functor。\n\n```js\nconst liftA2 = curry((f, functor1, functor2) => functor1.map(f).ap(functor2));\n```\n\n### 操作符\n\n  haskell 中可以使用 `<$>` 表示 `map`, `<*>` 表示 `ap`。\n\n```js\nFunctor.of(2).map(add).ap(Functor.of(3));\n// map(add, Functor.of(2)).ap(Functor.of(3));\n```\n\n等同于：\n\n```haskell\nadd <$> Functor 2 <*> Functor 3\n```\n\n## 定律\n- 同一：`A.of(id).ap(v) == v`\n- 同态：`A.of(f).ap(A.of(x)) == A.of(f(x))`\n- 互换：`v.ap(A.of(x)) == A.of(f => f(x)).ap(x)`\n- 组合：`A.of(compomse).ap(u).ap(v).ap(w) == u.ap(v.ap(w))`\n\n","frontmatter":{"title":"JavaScript 函数式编程笔记","date":"2018年9月15日","tags":["JavaScript","FP"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/javascript-functional-programming-notes/"}}}