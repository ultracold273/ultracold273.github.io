{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/the-right-way-to-array-of-random-sequence/","result":{"data":{"markdownRemark":{"html":"<p>在 <code>underscore</code> 中有一个函数，其作用是将数组乱序排序，实现如下：</p>\n<pre><code class=\"language-js\">// Shuffle a collection, using the modern version of the\n// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n// `shuffle` 函数。\n_.shuffle = function(obj) {\n  var set = isArrayLike(obj) ? obj : _.values(obj);\n  var length = set.length;\n  var shuffled = Array(length);\n  for (var index = 0, rand; index &#x3C; length; index++) {\n    rand = _.random(0, index);\n    if (rand !== index) shuffled[index] = shuffled[rand];\n    shuffled[rand] = set[index];\n  }\n  return shuffled;\n};\n</code></pre>\n<!--more-->\n<p>其中使用的数组乱序的算法是 <a href=\"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\">Fisher–Yates shuffle</a>。这是一个 O(n) 复杂度的随机排列数组元素的经典算法。</p>\n<p>每次循环从前面的 <code>index</code> 个元素中随机选择一个元素 <code>shuffle[rand]</code>。将这个元素与第 <code>index</code> 个元素进行交换，直到 <code>index == length</code> 为止。这样对元素进行随机交换，对于每个结果所获得概率是均匀的。<code>_.shuffle</code> 方法是返回一个新的乱序数组，所以需要一个新的数组来存储。</p>\n<p>对原有数组进行乱序：</p>\n<pre><code class=\"language-js\">function shuffle(arr) {\n  var length = arr.length;\n  for (var index = 0, rand; index &#x3C; length; index ++) {\n    rand = Math.floor(Math.random() * (length - 1));\n\n    var temp = arr[rand];\n    arr[rand] = arr[index];\n    arr[index] = temp;\n  }\n  return arr;\n}\n</code></pre>\n<p><strong>More</strong></p>\n<ul>\n<li><a href=\"https://github.com/hanzichi/underscore-analysis/issues/15\">JavaScript 数组乱序</a></li>\n<li><a href=\"https://www.h5jun.com/post/array-shuffle.html\">数组的完全随机排列</a></li>\n</ul>","rawMarkdownBody":"\n在 `underscore` 中有一个函数，其作用是将数组乱序排序，实现如下：\n\n``` js\n// Shuffle a collection, using the modern version of the\n// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n// `shuffle` 函数。\n_.shuffle = function(obj) {\n  var set = isArrayLike(obj) ? obj : _.values(obj);\n  var length = set.length;\n  var shuffled = Array(length);\n  for (var index = 0, rand; index < length; index++) {\n    rand = _.random(0, index);\n    if (rand !== index) shuffled[index] = shuffled[rand];\n    shuffled[rand] = set[index];\n  }\n  return shuffled;\n};\n```\n<!--more-->\n\n其中使用的数组乱序的算法是 [Fisher–Yates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)。这是一个 O(n) 复杂度的随机排列数组元素的经典算法。\n\n每次循环从前面的 `index` 个元素中随机选择一个元素 `shuffle[rand]`。将这个元素与第 `index` 个元素进行交换，直到 `index == length` 为止。这样对元素进行随机交换，对于每个结果所获得概率是均匀的。`_.shuffle` 方法是返回一个新的乱序数组，所以需要一个新的数组来存储。\n\n对原有数组进行乱序：\n\n``` js\nfunction shuffle(arr) {\n  var length = arr.length;\n  for (var index = 0, rand; index < length; index ++) {\n    rand = Math.floor(Math.random() * (length - 1));\n\n    var temp = arr[rand];\n    arr[rand] = arr[index];\n    arr[index] = temp;\n  }\n  return arr;\n}\n```\n\n**More**\n- [JavaScript 数组乱序](https://github.com/hanzichi/underscore-analysis/issues/15)\n- [数组的完全随机排列](https://www.h5jun.com/post/array-shuffle.html)\n","frontmatter":{"title":"数组乱序的正确姿势","date":"2016年7月25日","tags":["JavaScript","前端","Underscore"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/the-right-way-to-array-of-random-sequence/"}}}