{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/write-a-react-from-scratch-init-render/","result":{"data":{"markdownRemark":{"html":"<p>该文章将阅读 React 初始化渲染相关的代码，并实现一个简单的将 JSX 渲染到页面的功能。（不包括组件生命周期与事件处理相关部分）</p>\n<!--more-->\n<h2>源码解析：渲染过程</h2>\n<h3>JSX 解析</h3>\n<p>我们知道在 React 组件<code>render()</code> 返回的是 JSX，而 JSX 将会被 babel 转换。JSX 将被转换为 <code>React.createElement(type, config, children)</code>的形式。</p>\n<pre><code class=\"language-js\">// App.js\n// 转换前\nClass App extends Component {\n    render() {\n        return &#x3C;h1 id='title'>Hello World&#x3C;h1>\n    }\n}\n\n// 转换后\nvar App = React.createClass({\n    render() {\n        return React.createElement('h1', {\n            id: 'title'\n        }, 'hello world')\n    }\n})\n</code></pre>\n<p><code>React.createElement()</code> 的实现位于 <a href=\"https://github.com/facebook/react/blob/15-stable/src/isomorphic/classic/element/ReactElement.js#L183\">/src/isomorphic/classic/element/ReactElement.js</a></p>\n<p>这里的 <code>React.createElement()</code>是用来生成虚拟 DOM 元素，该函数对组件的属性，事件，子组件等进行了处理，并返回值为一个 <code>ReactElement</code> 对象（单纯的 JavaScript 对象，仅包括 type, props, key, ref 等属性）。</p>\n<p>这恰好说明了 JSX 中的 <code>&#x3C;h1 id='title'>hello world&#x3C;/h1></code>实际上是 JavaScript 对象，而不是我们通常写的 HTML 标签。</p>\n<h3>渲染到页面</h3>\n<p>单单声明了组件而没有渲染到页面上我们是看不见的（废话），所以我们需要使用 <code>ReactDOM.render()</code>将其渲染到页面指定位置上。</p>\n<pre><code class=\"language-js\">// index.html\n&#x3C;html>\n    // ...\n    &#x3C;body>\n        &#x3C;div id='root'>&#x3C;/div>\n    &#x3C;/body>\n&#x3C;/html>\n\n\n// index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App.js'\n\nReactDOM.render(&#x3C;App />, document.getElementById('root'))\n</code></pre>\n<p><code>ReactDOM.render()</code> 的实现位于<a href=\"https://github.com/facebook/react/blob/master/src/renderers/dom/stack/client/ReactMount.js#L581\"> </a><a href=\"https://github.com/facebook/react/blob/15-stable/src/renderers/dom/client/ReactMount.js\">/src/renderers/dom/client/ReactMount.js</a></p>\n<p><code>ReactDOM.render()</code> 函数将会根据 <code>ReactElement</code> 的类型生成相对应的<code>ReactComponent</code> 实例，并调用其 <code>mountComponent()</code>函数进行组件加载（返回 HTML片段），递归加载所有组件后，通过 <a href=\"https://github.com/facebook/react/blob/b1768b5a48d1f82e4ef4150e0036c5f846d3758a/src/renderers/dom/shared/setInnerHTML.js\">setInnerHTML</a> 将 HTML 渲染到页面上。</p>\n<p>判断需要生成那种 <code>ReactComponent</code>实例根据 <code>ReactElement</code> 对象的 type 属性来决定。对应 HTML 标签的 type 一般为字符串，而自定义的组件则是大写字母开头的组件函数（自定义组件需要 import，而 HTML 标签不需要）。</p>\n<h4>生成 <strong>ReactComponent</strong></h4>\n<p>React 中生成对应的 <code>ReactComponent</code>实例由 <code>instantiateReactComponent()</code>完成，其实现位于 <a href=\"https://github.com/facebook/react/blob/15-stable/src/renderers/shared/stack/reconciler/instantiateReactComponent.js\">/src/renderers/shared/stack/reconciler/instantiateReactComponent.js</a></p>\n<p><code>ReactComponent</code> 分为 3 种：</p>\n<ul>\n<li><code>ReactEmptyComponent</code>:  空组件（ReactElement 的 type 属性为 null 或 false 的组件），在浏览器中返回 <code>ReactDOMEmptyComponent</code>。</li>\n<li>\n<p><code>ReactHostComponent</code>: 原生组件（ReactElement 为string，number 或 ReactElement 的 type 属性为 string 的组件）。</p>\n<ul>\n<li><code>createInternalComponent()</code>：该函数用于创建原生组件，在浏览器中返回 <code>ReactDOMComponent</code>。</li>\n<li><code>createInstanceForText()</code> : 该函数用于创建纯文本组件，在浏览器中返回 <code>ReactDOMTextComponent</code>。</li>\n</ul>\n</li>\n<li><code>ReactCompositeComponent</code>: 自定义组件（ReactElement 的 type 属性为 function）</li>\n</ul>\n<p>可以发现 React 与平台解耦，使用 <code>ReactEmptyComponent</code> 与 <code>ReactHostComponent</code>。而这两种组件会根据平台的不同生成不同的组件对象，在浏览器中则为 <code>ReactDOMEmptyComponent</code>、<code>ReactDOMComponent</code> 与 <code>ReactDOMTextComponent</code>。</p>\n<p>它们通过 <a href=\"https://github.com/facebook/react/blob/15-stable/src/renderers/dom/stack/client/ReactDOMStackInjection.js\">/src/renderers/dom/stack/client/ReactDOMStackInjection.js</a> 进行注入。</p>\n<p>（ <a href=\"https://github.com/facebook/react/tree/15-stable/src/renderers\">/src/renderers </a>路径下包含各个平台上不同的 ReactComponent 实现，包括 react-art/react-dom/react-native。）</p>\n<h2>从零开始：实现初始化渲染</h2>\n<h3>设置 babel</h3>\n<p>首先我们需要了解 babel 如何转换 JSX：<a href=\"https://babeljs.io/docs/plugins/transform-react-jsx/\">React JSX transform</a>。</p>\n<p>babel 可以通过<code>transform-react-jsx</code>插件来设置解析 JSX 之后调用的函数，默认解析为调用 <code>React.createElement()</code>。所以这就是为什么虽然在 JSX 代码中没有使用到 React，却仍然需要导入它。</p>\n<p>通过配置 <code>transform-react-jsx</code>插件的 <code>pragma</code>选项可以修改解析后调用的函数。</p>\n<pre><code class=\"language-js\">// 修改解析为调用 dom() 函数\n{\n  \"plugins\": [\n    [\"transform-react-jsx\", {\n      \"pragma\": \"dom\" // 默认 pragma 为 React.createElement\n    }]\n  ]\n}\n</code></pre>\n<p>babel 将会把 JSX 中的标签名作为第一个参数，把 JSX 中的标签属性作为第二个参数，将标签内容作为剩余的参数。传递这些参数给 <code>pragma</code> 选项设置的函数。</p>\n<p><strong>PS: 为了方便起见，我们使用默认的解析为 React.createElement()</strong></p>\n<h3>实现 createElement</h3>\n<p><code>createElement()</code>接受至少 2 个参数：元素类型 type（字符串表示原生元素，函数表示自定义元素），元素设置 config。其他参数视为元素的子元素 children。并且该函数返回的是一个 <code>ReactElement</code> 对象，属性包括 type, props, key, ref。</p>\n<pre><code class=\"language-js\">// element.js\nclass ReactElement {\n    constructor(type, props, key, ref) {\n        this.type = type\n        this.props = props\n        this.key = key\n        this.ref = ref\n    }\n}\n\nexport function createElement(type, config, ...children)｛\n    // ...\n    return new ReactElement(type, props, key, ref)\n｝\n</code></pre>\n<p>然后需要导出 <code>createElement</code>，才能够通过 <code>React.createElement()</code> 的方式调用。</p>\n<pre><code class=\"language-js\">// index.js\nimport { createElement } from './element'\n\nconst React = {\n    createElement,\n}\n\nexport default React\n</code></pre>\n<p><code>ReactElement</code>需要 props, key 与 ref 参数，这三个参数将通过处理 config 与 children 得到。</p>\n<p>我们将从 config 中获取 key 与 ref（若它们存在的话），并且根据 config 得到 props (去除一些不必要的属性)，同时将 children 添加到 props 当中。</p>\n<pre><code class=\"language-js\">export function createElement(type, config, ...children) {\n  let props = {}\n  let key = null\n  let ref = null\n\n  if (config != null) {\n    ref = config.ref === undefined ? null : config.ref\n    // 当 key 为数字时，将 key 转换为字符串\n    key = config.key === undefined ? null : '' + config.key\n\n    for (let propsName in config) {\n      // 剔除一些不需要的属性（key, ref, __self, __source）\n      if (RESERVED_PROPS.hasOwnProperty(propsName)) {\n        continue\n      }\n\n      if (config.hasOwnProperty(propsName)) {\n        props[propsName] = config[propsName]\n      }\n    }\n\n    props.children = children\n  }\n\n  return new ReactElement(type, props, key, ref)\n}\n</code></pre>\n<p>除此之外，添加对 <code>defaultProps</code> 的支持。<code>defaultProps</code> 的使用方式如下：</p>\n<pre><code class=\"language-js\">// App.js\nclass App extends Component {\n}\n\nApp.defaultProps = {\n    name: \"ahonn\"\n}\n</code></pre>\n<p>当传入 App 组件的 props 中不包含 name 时，设置默认的 name 为 \"ahonn\"。具体实现：当 ReactElement 的 type 属性为组件函数且包含 defaultProps 时遍历 props，若 props 中不包含  defaultProps 中的属性时，设置默认的 props。</p>\n<pre><code class=\"language-js\">export function createElement(type, config, ...children) {\n    // ...\n    if (type &#x26;&#x26; type.defaultProps) {\n        let defaultProps = type.defaultProps\n        for (let propsName in defaultProps) {\n            if (props[propsName] === undefined) {\n                props[propsName] = defaultProps[propsName]\n            }\n        }\n    }\n}\n</code></pre>\n<p>目前为止完成了将 JSX 解析为函数调用（这部分由 babel 完成），调用 <code>React.createElement()</code> 生成 <code>ReactElement</code> 对象。</p>\n<p>接下来将实现 <code>instantiateReactComponent()</code>，通过 ReactELemnt 生成相对应的 <code>ReactComponent</code> 实例。</p>\n<h3>实现工厂方法 instantiateReactComponent</h3>\n<p><code>instantiateReactComponent(element)</code>接受一个参数 element，该参数可以是 ReactElement 对象，string，number，false 或者 null。</p>\n<p>我们将只考虑 Web 端，而不像 React 一样使用适配器模式进行解耦。</p>\n<p>ReactElement 生成相应 ReactComponent 实例的规则：</p>\n<ul>\n<li>element 为 null 或 false 时，生成 ReactDOMEmptyComponent 对象实例</li>\n<li>element 为 string 或者 number 时，生成 ReactDOMTextComponent 对象实例</li>\n<li>\n<p>element 为 object</p>\n<ul>\n<li>element.type 为 string 时，生成 ReactDOMComponent 对象实例</li>\n<li>element.type 为 function（组件函数）时，生成 ReactCompositeComponent 对象实例</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">// virtual-dom.js\nexport function instantiateReactComponent(element) {\n  let instance = null\n  if (element === null || element === false) {\n    instance = new ReactDOMEmptyComponent()\n  }\n\n  if (typeof element === 'string' || typeof element === 'number') {\n    instance = new ReactDOMTextComponent(element)\n  }\n\n  if (typeof element === 'object') {\n    let type = element.type\n    if (typeof type === 'string') {\n      instance = new ReactDomComponent(element)\n    } else if (typeof type === 'function'){\n      instance = new ReactCompositeComponent(element)\n    }\n  }\n  return instance\n}\n</code></pre>\n<h3>实现 ReactComponent</h3>\n<p>现在，我们需要有不同的 <code>ReactComponent</code> 类以供 <code>instantiateReactComponent()</code>使用。同时需要实现每个类的 <code>mountComponent()</code> 方法来返回对应的 HTML 片段。</p>\n<p><strong>ReactDOMEmptyComponent</strong></p>\n<p><code>ReactDOMEmptyComponent</code> 表示空组件， <code>mountComponent()</code> 方法返回空字符串。</p>\n<pre><code class=\"language-js\">class ReactDOMEmptyComponent {\n  constructor() {\n    this._element = null\n  }\n\n  mountComponent() {\n    return ''\n  }\n}\n</code></pre>\n<p><strong>ReactDOMTextComponent</strong></p>\n<p>ReactDOMTextComponent 表示 DOM 文本组件，<code>mountComponent()</code>方法返回对应的字符串。</p>\n<pre><code class=\"language-js\">class ReactDOMTextComponent {\n  constructor(text) {\n    this._element = text\n    this._stringText = '' + text\n    this._rootID = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootID = rootID\n    return this._stringText\n  }\n}\n</code></pre>\n<p><strong>ReactDOMComponent</strong></p>\n<p>ReactDOMComponent 表示原生组件，即浏览器支持的标签（div, p, h1, etc.）。<code>mountConponent()</code> 方法返回对应的 HTML 字符串。</p>\n<pre><code class=\"language-js\">class ReactDomComponent {\n  constructor(element) {\n    let tag = element.type\n\n    this._element = element\n    this._tag = tag.toLowerCase()\n    this._rootID = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootID = rootID\n    if (typeof this._element.type !== 'string') {\n      throw new Error('DOMComponent\\'s Element.type must be string')\n    }\n\n    let ret = `&#x3C;${this._tag} `\n    let props = this._element.props\n    for (var propsName in props) {\n      if (propsName === 'children') {\n        continue\n      }\n      let propsValue = props[propsName]\n      ret += `${propsName}=${propsValue}`\n    }\n    ret += '>'\n\n    let tagContent = ''\n    if (props.children) {\n      tagContent = this._mountChildren(props.children)\n    }\n    ret += tagContent\n    ret += `&#x3C;/${this._tag}>`\n    return ret\n  }\n}\n</code></pre>\n<p><code>ReactDOMComponent</code> 的 <code>mountComponent()</code>方法会相对复杂一点。具体实现思路是，通过 <code>ReactElement</code> 的 type 与 props 属性拼接对应的 HTML 标签。处理 props 的时候需要跳过 children 属性，因为需要将子组件放在当前组件中。</p>\n<p>当存在子组件（children）时，调用 <code>_mountChildren(children)</code>将组件转换为对应的 HTML 片段。具体过程是遍历 children，转换为 <code>ReactComponent</code> 并调用其 <code>mountComponent()</code> 方法。</p>\n<pre><code class=\"language-js\">_mountChildren(children) {\n  let result = ''\n  for (let index in children) {\n    const child = children[index]\n    const childrenComponent = instantiateReactComponent(child)\n    result += childrenComponent.mountComponent(index)\n  }\n  return result\n}\n</code></pre>\n<p><strong>ReactCompositeComponent</strong></p>\n<p>ReactCompositeComponent 表示自定义的组件，<code>mountComponent()</code>方法将根据提供的组件函数（element.type）实例化，并调用该组件的 <code>render()</code>方法返回 <code>ReactElement</code> 对象。再通过<code>instantiateReactComponent()</code> 生成对应的 <code>ReactComponent</code>，最后执行该 <code>ReactComponent</code> 的<code>mountComponent()</code>方法。</p>\n<pre><code class=\"language-js\">class ReactCompositeComponent {\n  constructor(element) {\n    this._element = element\n    this._rootId = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootId = rootID\n    if (typeof this._element.type !== 'function') {\n      throw new Error('CompositeComponent\\'s Element.type must be function')\n    }\n\n    const Component = this._element.type\n    const props = this._element.props\n    const instance = new Component(props)\n\n    const renderedElement = instance.render()\n    const renderedComponent = instantiateReactComponent(renderedElement)\n    const renderedResult = renderedComponent.mountComponent(rootID)\n    return renderedResult\n  }\n}\n</code></pre>\n<p>通过 ReactCompositeComponent 将之前的 ReactComponent 联系起来，并递归调用 <code>mountComponent</code>方法得到一段 HTML。最后 <code>render()</code>通过 node.innerHTML 将 HTML 字符串填到页面上对应的容器中。</p>\n<h3>实现 render</h3>\n<p>最后将之前的实现串起来，利用 innerHTML 将组件渲染到页面上。</p>\n<pre><code class=\"language-js\">export function render(element, container) {\n  const rootID = 0\n  const mainComponent = instantiateReactComponent(element)\n  const containerContent = mainComponent.mountComponent(rootID)\n\n  container.innerHTML = containerContent\n}\n</code></pre>\n<p>到这里就基本上简单的实现了 React 中将组件渲染到页面上的部分。可以通过一个简单的例子验证一下。</p>\n<pre><code class=\"language-js\">// index.js\nimport React from './tiny-react'\nimport ReactDOM from './tiny-react'\nimport App from './App'\n\nReactDOM.render(&#x3C;App />, document.getElementById('root'))\n\n// App.js\n\nimport React, { Component } from './tiny-react'\n\nclass App extends Component {\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;span>It is Work!&#x3C;/span>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<p>页面上将显示 It is Work!</p>\n<h2>后记</h2>\n<p>虽然没有涉及到组件更新与组件生命周期，通过阅读 React 的源码基本上也对初始化渲染的过程有了一定的了解，希望对你有所帮助。</p>\n<p>在此感谢 <a href=\"https://github.com/developit/preact\">preact</a>, <a href=\"https://github.com/Lucifier129/react-lite\">react-lite</a>, <a href=\"https://github.com/CodeFalling/react-tiny\">react-tiny</a> 等项目，它们为本文提供了很大帮助。</p>\n<p>文中的所有代码均于 <a href=\"https://github.com/ahonn/tiny-react/tree/init-render\">tiny-react init-render</a> ，感谢阅读。</p>","rawMarkdownBody":"\n该文章将阅读 React 初始化渲染相关的代码，并实现一个简单的将 JSX 渲染到页面的功能。（不包括组件生命周期与事件处理相关部分）\n\n<!--more-->\n\n## 源码解析：渲染过程\n\n### JSX 解析\n\n我们知道在 React 组件`render()` 返回的是 JSX，而 JSX 将会被 babel 转换。JSX 将被转换为 `React.createElement(type, config, children)`的形式。\n\n```js\n// App.js\n// 转换前\nClass App extends Component {\n    render() {\n        return <h1 id='title'>Hello World<h1>\n    }\n}\n\n// 转换后\nvar App = React.createClass({\n    render() {\n        return React.createElement('h1', {\n            id: 'title'\n        }, 'hello world')\n    }\n})\n```\n\n`React.createElement()` 的实现位于 [/src/isomorphic/classic/element/ReactElement.js](https://github.com/facebook/react/blob/15-stable/src/isomorphic/classic/element/ReactElement.js#L183)\n\n这里的 `React.createElement()`是用来生成虚拟 DOM 元素，该函数对组件的属性，事件，子组件等进行了处理，并返回值为一个 `ReactElement` 对象（单纯的 JavaScript 对象，仅包括 type, props, key, ref 等属性）。\n\n这恰好说明了 JSX 中的 `<h1 id='title'>hello world</h1>`实际上是 JavaScript 对象，而不是我们通常写的 HTML 标签。\n\n### 渲染到页面\n\n单单声明了组件而没有渲染到页面上我们是看不见的（废话），所以我们需要使用 `ReactDOM.render()`将其渲染到页面指定位置上。\n\n```js\n// index.html\n<html>\n    // ...\n    <body>\n        <div id='root'></div>\n    </body>\n</html>\n\n\n// index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App.js'\n\nReactDOM.render(<App />, document.getElementById('root'))\n```\n\n`ReactDOM.render()` 的实现位于[ ](https://github.com/facebook/react/blob/master/src/renderers/dom/stack/client/ReactMount.js#L581)[/src/renderers/dom/client/ReactMount.js](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/client/ReactMount.js)\n\n`ReactDOM.render()` 函数将会根据 `ReactElement` 的类型生成相对应的`ReactComponent` 实例，并调用其 `mountComponent()`函数进行组件加载（返回 HTML片段），递归加载所有组件后，通过 [setInnerHTML](https://github.com/facebook/react/blob/b1768b5a48d1f82e4ef4150e0036c5f846d3758a/src/renderers/dom/shared/setInnerHTML.js) 将 HTML 渲染到页面上。\n\n判断需要生成那种 `ReactComponent`实例根据 `ReactElement` 对象的 type 属性来决定。对应 HTML 标签的 type 一般为字符串，而自定义的组件则是大写字母开头的组件函数（自定义组件需要 import，而 HTML 标签不需要）。\n\n#### 生成 **ReactComponent**\n\nReact 中生成对应的 `ReactComponent`实例由 `instantiateReactComponent()`完成，其实现位于 [/src/renderers/shared/stack/reconciler/instantiateReactComponent.js](https://github.com/facebook/react/blob/15-stable/src/renderers/shared/stack/reconciler/instantiateReactComponent.js)\n\n`ReactComponent` 分为 3 种：\n\n* `ReactEmptyComponent`:  空组件（ReactElement 的 type 属性为 null 或 false 的组件），在浏览器中返回 `ReactDOMEmptyComponent`。\n\n* `ReactHostComponent`: 原生组件（ReactElement 为string，number 或 ReactElement 的 type 属性为 string 的组件）。\n\n  * `createInternalComponent()`：该函数用于创建原生组件，在浏览器中返回 `ReactDOMComponent`。\n\n  * `createInstanceForText()` : 该函数用于创建纯文本组件，在浏览器中返回 `ReactDOMTextComponent`。\n\n* `ReactCompositeComponent`: 自定义组件（ReactElement 的 type 属性为 function）\n\n可以发现 React 与平台解耦，使用 `ReactEmptyComponent` 与 `ReactHostComponent`。而这两种组件会根据平台的不同生成不同的组件对象，在浏览器中则为 `ReactDOMEmptyComponent`、`ReactDOMComponent` 与 `ReactDOMTextComponent`。\n\n它们通过 [/src/renderers/dom/stack/client/ReactDOMStackInjection.js](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/stack/client/ReactDOMStackInjection.js) 进行注入。\n\n（ [/src/renderers ](https://github.com/facebook/react/tree/15-stable/src/renderers)路径下包含各个平台上不同的 ReactComponent 实现，包括 react-art/react-dom/react-native。）\n\n## 从零开始：实现初始化渲染\n\n### 设置 babel\n\n首先我们需要了解 babel 如何转换 JSX：[React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/)。\n\nbabel 可以通过`transform-react-jsx`插件来设置解析 JSX 之后调用的函数，默认解析为调用 `React.createElement()`。所以这就是为什么虽然在 JSX 代码中没有使用到 React，却仍然需要导入它。\n\n通过配置 `transform-react-jsx`插件的 `pragma`选项可以修改解析后调用的函数。\n\n```js\n// 修改解析为调用 dom() 函数\n{\n  \"plugins\": [\n    [\"transform-react-jsx\", {\n      \"pragma\": \"dom\" // 默认 pragma 为 React.createElement\n    }]\n  ]\n}\n```\n\nbabel 将会把 JSX 中的标签名作为第一个参数，把 JSX 中的标签属性作为第二个参数，将标签内容作为剩余的参数。传递这些参数给 `pragma` 选项设置的函数。\n\n**PS: 为了方便起见，我们使用默认的解析为 React.createElement\\(\\)**\n\n### 实现 createElement\n\n`createElement()`接受至少 2 个参数：元素类型 type（字符串表示原生元素，函数表示自定义元素），元素设置 config。其他参数视为元素的子元素 children。并且该函数返回的是一个 `ReactElement` 对象，属性包括 type, props, key, ref。\n\n```js\n// element.js\nclass ReactElement {\n    constructor(type, props, key, ref) {\n        this.type = type\n        this.props = props\n        this.key = key\n        this.ref = ref\n    }\n}\n\nexport function createElement(type, config, ...children)｛\n    // ...\n    return new ReactElement(type, props, key, ref)\n｝\n```\n\n然后需要导出 `createElement`，才能够通过 `React.createElement()` 的方式调用。\n\n```js\n// index.js\nimport { createElement } from './element'\n\nconst React = {\n    createElement,\n}\n\nexport default React\n```\n\n`ReactElement`需要 props, key 与 ref 参数，这三个参数将通过处理 config 与 children 得到。\n\n我们将从 config 中获取 key 与 ref（若它们存在的话），并且根据 config 得到 props \\(去除一些不必要的属性\\)，同时将 children 添加到 props 当中。\n\n```js\nexport function createElement(type, config, ...children) {\n  let props = {}\n  let key = null\n  let ref = null\n\n  if (config != null) {\n    ref = config.ref === undefined ? null : config.ref\n    // 当 key 为数字时，将 key 转换为字符串\n    key = config.key === undefined ? null : '' + config.key\n\n    for (let propsName in config) {\n      // 剔除一些不需要的属性（key, ref, __self, __source）\n      if (RESERVED_PROPS.hasOwnProperty(propsName)) {\n        continue\n      }\n\n      if (config.hasOwnProperty(propsName)) {\n        props[propsName] = config[propsName]\n      }\n    }\n\n    props.children = children\n  }\n\n  return new ReactElement(type, props, key, ref)\n}\n```\n\n除此之外，添加对 `defaultProps` 的支持。`defaultProps` 的使用方式如下：\n\n```js\n// App.js\nclass App extends Component {\n}\n\nApp.defaultProps = {\n    name: \"ahonn\"\n}\n```\n\n当传入 App 组件的 props 中不包含 name 时，设置默认的 name 为 \"ahonn\"。具体实现：当 ReactElement 的 type 属性为组件函数且包含 defaultProps 时遍历 props，若 props 中不包含  defaultProps 中的属性时，设置默认的 props。\n\n```js\nexport function createElement(type, config, ...children) {\n    // ...\n    if (type && type.defaultProps) {\n        let defaultProps = type.defaultProps\n        for (let propsName in defaultProps) {\n            if (props[propsName] === undefined) {\n                props[propsName] = defaultProps[propsName]\n            }\n        }\n    }\n}\n```\n\n目前为止完成了将 JSX 解析为函数调用（这部分由 babel 完成），调用 `React.createElement()` 生成 `ReactElement` 对象。\n\n接下来将实现 `instantiateReactComponent()`，通过 ReactELemnt 生成相对应的 `ReactComponent` 实例。\n\n### 实现工厂方法 instantiateReactComponent\n\n`instantiateReactComponent(element)`接受一个参数 element，该参数可以是 ReactElement 对象，string，number，false 或者 null。\n\n我们将只考虑 Web 端，而不像 React 一样使用适配器模式进行解耦。\n\nReactElement 生成相应 ReactComponent 实例的规则：\n\n* element 为 null 或 false 时，生成 ReactDOMEmptyComponent 对象实例\n\n* element 为 string 或者 number 时，生成 ReactDOMTextComponent 对象实例\n\n* element 为 object\n\n  * element.type 为 string 时，生成 ReactDOMComponent 对象实例\n\n  * element.type 为 function（组件函数）时，生成 ReactCompositeComponent 对象实例\n\n```js\n// virtual-dom.js\nexport function instantiateReactComponent(element) {\n  let instance = null\n  if (element === null || element === false) {\n    instance = new ReactDOMEmptyComponent()\n  }\n\n  if (typeof element === 'string' || typeof element === 'number') {\n    instance = new ReactDOMTextComponent(element)\n  }\n\n  if (typeof element === 'object') {\n    let type = element.type\n    if (typeof type === 'string') {\n      instance = new ReactDomComponent(element)\n    } else if (typeof type === 'function'){\n      instance = new ReactCompositeComponent(element)\n    }\n  }\n  return instance\n}\n```\n\n### 实现 ReactComponent\n\n现在，我们需要有不同的 `ReactComponent` 类以供 `instantiateReactComponent()`使用。同时需要实现每个类的 `mountComponent()` 方法来返回对应的 HTML 片段。\n\n**ReactDOMEmptyComponent**\n\n`ReactDOMEmptyComponent` 表示空组件， `mountComponent()` 方法返回空字符串。\n\n```js\nclass ReactDOMEmptyComponent {\n  constructor() {\n    this._element = null\n  }\n\n  mountComponent() {\n    return ''\n  }\n}\n```\n\n**ReactDOMTextComponent**\n\nReactDOMTextComponent 表示 DOM 文本组件，`mountComponent()`方法返回对应的字符串。\n\n```js\nclass ReactDOMTextComponent {\n  constructor(text) {\n    this._element = text\n    this._stringText = '' + text\n    this._rootID = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootID = rootID\n    return this._stringText\n  }\n}\n```\n\n**ReactDOMComponent**\n\nReactDOMComponent 表示原生组件，即浏览器支持的标签（div, p, h1, etc.）。`mountConponent()` 方法返回对应的 HTML 字符串。\n\n```js\nclass ReactDomComponent {\n  constructor(element) {\n    let tag = element.type\n\n    this._element = element\n    this._tag = tag.toLowerCase()\n    this._rootID = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootID = rootID\n    if (typeof this._element.type !== 'string') {\n      throw new Error('DOMComponent\\'s Element.type must be string')\n    }\n\n    let ret = `<${this._tag} `\n    let props = this._element.props\n    for (var propsName in props) {\n      if (propsName === 'children') {\n        continue\n      }\n      let propsValue = props[propsName]\n      ret += `${propsName}=${propsValue}`\n    }\n    ret += '>'\n\n    let tagContent = ''\n    if (props.children) {\n      tagContent = this._mountChildren(props.children)\n    }\n    ret += tagContent\n    ret += `</${this._tag}>`\n    return ret\n  }\n}\n```\n\n`ReactDOMComponent` 的 `mountComponent()`方法会相对复杂一点。具体实现思路是，通过 `ReactElement` 的 type 与 props 属性拼接对应的 HTML 标签。处理 props 的时候需要跳过 children 属性，因为需要将子组件放在当前组件中。\n\n当存在子组件（children）时，调用 `_mountChildren(children)`将组件转换为对应的 HTML 片段。具体过程是遍历 children，转换为 `ReactComponent` 并调用其 `mountComponent()` 方法。\n\n```js\n_mountChildren(children) {\n  let result = ''\n  for (let index in children) {\n    const child = children[index]\n    const childrenComponent = instantiateReactComponent(child)\n    result += childrenComponent.mountComponent(index)\n  }\n  return result\n}\n```\n\n**ReactCompositeComponent**\n\nReactCompositeComponent 表示自定义的组件，`mountComponent()`方法将根据提供的组件函数（element.type）实例化，并调用该组件的 `render()`方法返回 `ReactElement` 对象。再通过`instantiateReactComponent()` 生成对应的 `ReactComponent`，最后执行该 `ReactComponent` 的`mountComponent()`方法。\n\n```js\nclass ReactCompositeComponent {\n  constructor(element) {\n    this._element = element\n    this._rootId = 0\n  }\n\n  mountComponent(rootID) {\n    this._rootId = rootID\n    if (typeof this._element.type !== 'function') {\n      throw new Error('CompositeComponent\\'s Element.type must be function')\n    }\n\n    const Component = this._element.type\n    const props = this._element.props\n    const instance = new Component(props)\n\n    const renderedElement = instance.render()\n    const renderedComponent = instantiateReactComponent(renderedElement)\n    const renderedResult = renderedComponent.mountComponent(rootID)\n    return renderedResult\n  }\n}\n```\n\n通过 ReactCompositeComponent 将之前的 ReactComponent 联系起来，并递归调用 `mountComponent`方法得到一段 HTML。最后 `render()`通过 node.innerHTML 将 HTML 字符串填到页面上对应的容器中。\n\n### 实现 render\n\n最后将之前的实现串起来，利用 innerHTML 将组件渲染到页面上。\n\n```js\nexport function render(element, container) {\n  const rootID = 0\n  const mainComponent = instantiateReactComponent(element)\n  const containerContent = mainComponent.mountComponent(rootID)\n\n  container.innerHTML = containerContent\n}\n```\n\n到这里就基本上简单的实现了 React 中将组件渲染到页面上的部分。可以通过一个简单的例子验证一下。\n\n```js\n// index.js\nimport React from './tiny-react'\nimport ReactDOM from './tiny-react'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// App.js\n\nimport React, { Component } from './tiny-react'\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <span>It is Work!</span>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n页面上将显示 It is Work!\n\n## 后记\n\n虽然没有涉及到组件更新与组件生命周期，通过阅读 React 的源码基本上也对初始化渲染的过程有了一定的了解，希望对你有所帮助。\n\n在此感谢 [preact](https://github.com/developit/preact), [react-lite](https://github.com/Lucifier129/react-lite), [react-tiny](https://github.com/CodeFalling/react-tiny) 等项目，它们为本文提供了很大帮助。\n\n文中的所有代码均于 [tiny-react init-render](https://github.com/ahonn/tiny-react/tree/init-render) ，感谢阅读。\n\n","frontmatter":{"title":"React 初始化渲染","date":"2017年6月8日","tags":["React","JavaScript","前端"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/write-a-react-from-scratch-init-render/"}}}