{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/starting-from-the-optimizeCb/","result":{"data":{"markdownRemark":{"html":"<h2>optimizeCb</h2>\n<p>在 <code>underscore</code> 中的内部函数 <code>optimizeCb</code>，顾名思义就是 optimize callback，即优化回调函数。</p>\n<p>optimizeCb:</p>\n<pre><code class=\"language-js\">// Internal function that returns an efficient (for current engines) version\n// of the passed-in callback, to be repeatedly applied in other Underscore\n// functions.\nvar optimizeCb = function(func, context, argCount) {\n  if (context === void 0) return func;\n  switch (argCount == null ? 3 : argCount) {\n    case 1: return function(value) {\n      return func.call(context, value);\n    };\n    // The 2-parameter case has been omitted only because no current consumers\n    // made use of it.\n    case 3: return function(value, index, collection) {\n      return func.call(context, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(context, accumulator, value, index, collection);\n    };\n  }\n  return function() {\n    return func.apply(context, arguments);\n  };\n};\n</code></pre>\n<!--more-->\n<p>它是这样处理回调的，当回调函数指定上下文环境时，根据 <code>argCount</code> 来分情况使用 <code>call</code>，不同情况的\n区别只是 <code>call</code> 除了上下文环境之外的函数参数的个数不同。</p>\n<p>除了参数个数为 1，3，4 使用 <code>call</code> 之外，其他情况使用 <code>apply</code>。这里原本存在的参数个数为 2 的\n情况被删除了，原因是因为参数为 2 个的情况在 <code>underscore</code> 中基本没有。就是说，对于常用的情况\n使用 <code>call</code>，而不常用的使用 <code>apply</code>。</p>\n<p>那么是不是 <code>call</code> 的性能相较于 <code>apply</code> 更好呢？</p>\n<h2>call 与 apply 的性能</h2>\n<p>使用 <code>optimizeCb</code> 与只使用 <code>apply</code> 的 <code>Cb</code> 进行比较</p>\n<pre><code class=\"language-js\">var Benchmark = require('benchmark');\nvar suite = new Benchmark.Suite;\n\nvar optimizeCb = function(func, context, argCount) {\n  if (context === void 0) return func;\n  switch (argCount == null ? 3 : argCount) {\n    case 1: return function(value) {\n      return func.call(context, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(context, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(context, accumulator, value, index, collection);\n    };\n  }\n  return function() {\n    return func.apply(context, arguments);\n  };\n};\n\nvar Cb = function(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  }\n};\n\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nsuite\n  .add('optimizeCb', function() {\n    optimizeCb(sum, this, 3)(24, 24, 24);\n  })\n  .add('Cb', function() {\n    cb(sum, this)(24, 24, 24);\n  })\n  .on('cycle', function(event) {\n  console.log(String(event.target));\n  })\n  .on('complete', function() {\n    console.log('Fastest is ' + this.filter('fastest').map('name'));\n  })\n  .run({ 'async': true });\n</code></pre>\n<p>测试结果：</p>\n<pre><code>optimizeCb x 16,373,430 ops/sec ±0.93% (80 runs sampled)\ncb x 8,729,305 ops/sec ±1.12% (90 runs sampled)\nFastest is optimizeCb\n</code></pre>\n<p>得出 <code>call</code> 在知道参数个数的时候比使用 <code>apply</code> 效率更高的结论。\n通过搜索，找到了一篇 <a href=\"http://blog.csdn.net/zhengyinhui100/article/details/7837127\">call和apply性能对比</a>。</p>\n<p>更严谨的说法是，当有this指向或者执行参数时，call的性能要明显优于apply。</p>\n<h2>结论</h2>\n<p>所以在编程过程中，如果要使用到 <code>call</code> 或者 <code>apply</code>，在知道参数个数的情况下，使用 <code>call</code> 是\n一个好选择，使得编译器能够去优化。</p>","rawMarkdownBody":"\n## optimizeCb\n在 `underscore` 中的内部函数 `optimizeCb`，顾名思义就是 optimize callback，即优化回调函数。\n\noptimizeCb:\n\n```js\n// Internal function that returns an efficient (for current engines) version\n// of the passed-in callback, to be repeatedly applied in other Underscore\n// functions.\nvar optimizeCb = function(func, context, argCount) {\n  if (context === void 0) return func;\n  switch (argCount == null ? 3 : argCount) {\n    case 1: return function(value) {\n      return func.call(context, value);\n    };\n    // The 2-parameter case has been omitted only because no current consumers\n    // made use of it.\n    case 3: return function(value, index, collection) {\n      return func.call(context, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(context, accumulator, value, index, collection);\n    };\n  }\n  return function() {\n    return func.apply(context, arguments);\n  };\n};\n```\n\n<!--more-->\n它是这样处理回调的，当回调函数指定上下文环境时，根据 `argCount` 来分情况使用 `call`，不同情况的\n区别只是 `call` 除了上下文环境之外的函数参数的个数不同。\n\n除了参数个数为 1，3，4 使用 `call` 之外，其他情况使用 `apply`。这里原本存在的参数个数为 2 的\n情况被删除了，原因是因为参数为 2 个的情况在 `underscore` 中基本没有。就是说，对于常用的情况\n使用 `call`，而不常用的使用 `apply`。\n\n那么是不是 `call` 的性能相较于 `apply` 更好呢？\n\n## call 与 apply 的性能\n使用 `optimizeCb` 与只使用 `apply` 的 `Cb` 进行比较\n\n```js\nvar Benchmark = require('benchmark');\nvar suite = new Benchmark.Suite;\n\nvar optimizeCb = function(func, context, argCount) {\n  if (context === void 0) return func;\n  switch (argCount == null ? 3 : argCount) {\n    case 1: return function(value) {\n      return func.call(context, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(context, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(context, accumulator, value, index, collection);\n    };\n  }\n  return function() {\n    return func.apply(context, arguments);\n  };\n};\n\nvar Cb = function(func, context) {\n  return function() {\n    return func.apply(context, arguments);\n  }\n};\n\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nsuite\n  .add('optimizeCb', function() {\n    optimizeCb(sum, this, 3)(24, 24, 24);\n  })\n  .add('Cb', function() {\n    cb(sum, this)(24, 24, 24);\n  })\n  .on('cycle', function(event) {\n  console.log(String(event.target));\n  })\n  .on('complete', function() {\n    console.log('Fastest is ' + this.filter('fastest').map('name'));\n  })\n  .run({ 'async': true });\n```\n\n测试结果：\n```\noptimizeCb x 16,373,430 ops/sec ±0.93% (80 runs sampled)\ncb x 8,729,305 ops/sec ±1.12% (90 runs sampled)\nFastest is optimizeCb\n```\n\n得出 `call` 在知道参数个数的时候比使用 `apply` 效率更高的结论。\n通过搜索，找到了一篇 [call和apply性能对比](http://blog.csdn.net/zhengyinhui100/article/details/7837127)。\n\n更严谨的说法是，当有this指向或者执行参数时，call的性能要明显优于apply。\n\n## 结论\n所以在编程过程中，如果要使用到 `call` 或者 `apply`，在知道参数个数的情况下，使用 `call` 是\n一个好选择，使得编译器能够去优化。\n","frontmatter":{"title":"从 optimizeCb 说起","date":"2016年5月3日","tags":["JavaScript","前端","Underscore"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/starting-from-the-optimizeCb/"}}}