{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/posts/python-multithreaded-preliminary/","result":{"data":{"markdownRemark":{"html":"<p>这两天在写 <a href=\"https://www.github.com/ahonn/Nada\">Nada</a> 的下载功能，遇到一个问题，在下载歌曲的时候整个界面都会卡住，必须等待下载完成才能够恢复，因为写的时候是直接顺序执行的，没有多线程。之前在写播放功能的时候是参考了别人的代码，自己其实对多线程部分不是很了解。然后趁着晚上了解一下 Python 的 thread 和 treading 模块。</p>\n<h2>Python 多线程支持</h2>\n<p>Pyhton 标准库提供了 thread 和 threading 模块来支持多线程，这意味着不需要重新下载这两个模块，只需要在代码中 import 这两个模块就可以了。</p>\n<h2>thread 模块</h2>\n<p>thread 模块是以低级、原始的方式来处理和控制线程，提供了一个简单的锁（相对于 threading 模块的锁的感觉来说的确是比较简单）。相对于 threading 模块来说，thread 模块更加灵活。</p>\n<!--more-->\n<ul>\n<li>\n<p><code>thread.start_new_thread(function, args [, kwargs])</code>\n创建一个新的线程，返回该线程的标识符。线程执行后将制动退出，即函数执行完毕。当遇到未处理的异常时也将退出，但不影响其他线程。</p>\n<ul>\n<li><code>function</code>：线程执行的函数。</li>\n<li><code>args</code>：线程执行函数的参数。</li>\n<li><code>kwargs</code>：为函数提供命名参数字典。</li>\n</ul>\n</li>\n<li><code>thread.exit()</code>\n结束当前进程，触发 SystemExit 异常。</li>\n<li><code>thread.get_ident()</code>\n返回当前线程的标识符，标识符为一个非零整数。</li>\n<li><code>thread.interrupt_main()</code>\n触发主线程的 KeyboardInterrupt 异常，子线程使用此方法来终端主线程。</li>\n<li><code>thread.allocate_lock()</code>\n创建 thread.LockType 锁类型，即为线程锁</li>\n</ul>\n<h3>thread.LockType</h3>\n<ul>\n<li>\n<p><code>Lock.acquire([ waitflag ])</code>\n获取锁，返回一个布尔值，成功返回 True，否则返回 False。</p>\n<p><code>waitflag</code>：默认值为非零整数，表示如果锁已经被其他线程占用，那么当前线程等待，直到其他线程释放锁，即为同步阻塞。如果将参数设置为 0，即表示当前线程会尝试获取锁，不管锁是否被占用，线程都不会等待。</p>\n</li>\n<li><code>Lock.release()</code>\n释放所占用的锁。</li>\n<li><code>Lock.locked()</code>\n判断锁是否被占用。</li>\n</ul>\n<h2>threading 模块</h2>\n<p>threading 模块是对 thread 模块的二次封装，提供更方便的 API 使用。大多数多线程使用 threading 模块编写。提供更复杂的锁（Lock &#x26; RLock），条件，事件等。</p>\n<ul>\n<li>\n<p><code>threading.Thread(group=None, target=None,name=None, args=(), kwargs={})</code>\n返回一个Thread对象，每个Thread对象代表着一个线程，可以通过start()方法，开始运行。</p>\n<ul>\n<li><code>group</code>：应该为 None ，该参数是留给未来的扩展时使用的</li>\n<li><code>target</code>：可调用对象（函数），在线程启动后执行</li>\n<li><code>name</code>：线程的名字，默认值为“Thread-N”，N 是一个十进制整数</li>\n<li><code>args</code>：target 调用对象的参数列表</li>\n<li><code>kwargs</code>：target 调用对象的关键字参数</li>\n</ul>\n</li>\n<li><code>threading.activeCount()</code>\n返回当前存活线程数</li>\n<li><code>threading.currentThread()</code>\n返回当前 Thread 对象</li>\n<li><code>threading.enumerate()</code>\n返回当前存活的 Thread 对象列表</li>\n<li><code>threading.Lock()</code>\n返回一个原始锁对象</li>\n</ul>\n<h3>threading.Thread</h3>\n<p>有两种方式来创建 threading.Thread 对象。一种方式是继承 Thread 类，重写父类的 run 方法，另一种方式是通过 threading.Thread() 函数创建。</p>\n<ul>\n<li><code>Thread.start()</code>\n启动线程</li>\n<li><code>Thread.join([timeout])</code>\n阻塞当前环境进程，直到调用此方法的线程终止，或者达到指定的 timeout</li>\n<li><code>Thread.getName()</code> &#x26; <code>Thread.setName()</code>\n获取线程名称 &#x26; 设置线程名称</li>\n<li><code>Thread.isAlive()</code>\n返回线程是否存活。返回 True 在线程开始运行直到终止。</li>\n</ul>\n<h3>threading.Lock</h3>\n<ul>\n<li><code>Lock.acquire([blocking])</code>\n获取锁。<code>blocking</code> 默认为 true，阻塞直到锁被释放。当 <code>blocking</code> 为 False 时，则不阻塞。</li>\n<li><code>Lock.release()</code>\n释放锁，没有返回值。当没有锁时，将会抛出 ThreadError 异常。</li>\n</ul>","rawMarkdownBody":"\n这两天在写 [Nada](https://www.github.com/ahonn/Nada) 的下载功能，遇到一个问题，在下载歌曲的时候整个界面都会卡住，必须等待下载完成才能够恢复，因为写的时候是直接顺序执行的，没有多线程。之前在写播放功能的时候是参考了别人的代码，自己其实对多线程部分不是很了解。然后趁着晚上了解一下 Python 的 thread 和 treading 模块。\n\n## Python 多线程支持\nPyhton 标准库提供了 thread 和 threading 模块来支持多线程，这意味着不需要重新下载这两个模块，只需要在代码中 import 这两个模块就可以了。\n\n## thread 模块\nthread 模块是以低级、原始的方式来处理和控制线程，提供了一个简单的锁（相对于 threading 模块的锁的感觉来说的确是比较简单）。相对于 threading 模块来说，thread 模块更加灵活。\n\n<!--more-->\n- `thread.start_new_thread(function, args [, kwargs])`\n  创建一个新的线程，返回该线程的标识符。线程执行后将制动退出，即函数执行完毕。当遇到未处理的异常时也将退出，但不影响其他线程。\n  * `function`：线程执行的函数。\n  * `args`：线程执行函数的参数。\n  * `kwargs`：为函数提供命名参数字典。\n\n- `thread.exit()`\n  结束当前进程，触发 SystemExit 异常。\n\n- `thread.get_ident()`\n  返回当前线程的标识符，标识符为一个非零整数。\n\n- `thread.interrupt_main()`\n  触发主线程的 KeyboardInterrupt 异常，子线程使用此方法来终端主线程。\n\n- `thread.allocate_lock()`\n  创建 thread.LockType 锁类型，即为线程锁\n\n### thread.LockType\n\n- `Lock.acquire([ waitflag ])`\n  获取锁，返回一个布尔值，成功返回 True，否则返回 False。\n\n  `waitflag`：默认值为非零整数，表示如果锁已经被其他线程占用，那么当前线程等待，直到其他线程释放锁，即为同步阻塞。如果将参数设置为 0，即表示当前线程会尝试获取锁，不管锁是否被占用，线程都不会等待。\n\n- `Lock.release()`\n  释放所占用的锁。\n\n- `Lock.locked()`\n  判断锁是否被占用。\n\n## threading 模块\nthreading 模块是对 thread 模块的二次封装，提供更方便的 API 使用。大多数多线程使用 threading 模块编写。提供更复杂的锁（Lock & RLock），条件，事件等。\n\n- `threading.Thread(group=None, target=None,name=None, args=(), kwargs={})`\n  返回一个Thread对象，每个Thread对象代表着一个线程，可以通过start()方法，开始运行。\n\n  * `group`：应该为 None ，该参数是留给未来的扩展时使用的\n  * `target`：可调用对象（函数），在线程启动后执行\n  * `name`：线程的名字，默认值为“Thread-N”，N 是一个十进制整数\n  * `args`：target 调用对象的参数列表\n  * `kwargs`：target 调用对象的关键字参数\n\n- `threading.activeCount()`\n  返回当前存活线程数\n\n- `threading.currentThread()`\n  返回当前 Thread 对象\n\n- `threading.enumerate()`\n  返回当前存活的 Thread 对象列表\n\n- `threading.Lock()`\n  返回一个原始锁对象\n\n### threading.Thread\n有两种方式来创建 threading.Thread 对象。一种方式是继承 Thread 类，重写父类的 run 方法，另一种方式是通过 threading.Thread() 函数创建。\n\n- `Thread.start()`\n  启动线程\n\n- `Thread.join([timeout])`\n  阻塞当前环境进程，直到调用此方法的线程终止，或者达到指定的 timeout\n\n- `Thread.getName()` & `Thread.setName()`\n  获取线程名称 & 设置线程名称\n\n- `Thread.isAlive()`\n  返回线程是否存活。返回 True 在线程开始运行直到终止。\n\n### threading.Lock\n- `Lock.acquire([blocking])`\n  获取锁。`blocking` 默认为 true，阻塞直到锁被释放。当 `blocking` 为 False 时，则不阻塞。\n\n- `Lock.release()`\n  释放锁，没有返回值。当没有锁时，将会抛出 ThreadError 异常。\n","frontmatter":{"title":"Python 多线程初步了解","date":"2016年2月20日","tags":["Python"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/python-multithreaded-preliminary/"}}}