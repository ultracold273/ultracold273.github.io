{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/posts/javascript-reduce-the-browser-reflow/","result":{"data":{"markdownRemark":{"html":"<h2>什么是浏览器回流</h2>\n<p>浏览器在显示网页时，需要计算每一个元素应该放置的位置，这个计算过程就称为浏览器回流（browser reflow）。回流会重新计算页面的布局，在回流中会重新计算元素的尺寸与位置，并且也会触发对子元素的回流。</p>\n<p>触发浏览器回流的操作：</p>\n<ul>\n<li>在 DOM 中插入，移除或者更新元素</li>\n<li>修改页面上的内容</li>\n<li>移动 DOM 元素</li>\n<li>修改元素 CSS 样式</li>\n<li>修改元素的类名</li>\n<li>调整窗口的大小</li>\n</ul>\n<!--more-->\n<p>基本上跟元素相关的操作都会触发浏览器回流。浏览器的回流需要耗时，尽量减少浏览器的回流，那么就可以提高整个网页的效率。</p>\n<h2>创建单一元素</h2>\n<p>当我们需要创建一个新元素插入到页面中，并且设置元素的属性。我们会这样做：</p>\n<pre><code class=\"language-js\">function addElement(parent, elementText) {\n  var element = document.createElement('a');\n  parent.appendChild(element);\n  element.innerHTML = anchorText;\n}\n</code></pre>\n<p>这样写会产生2次浏览器回流，新创建的元素在插入页面中之后又进行了属性的修改。更好的写法是把插入到页面的操作放到最后，这样给元素设置属性的操作就是在内存中进行的。这样就只有元素插入到页面时产生的一次回流。</p>\n<pre><code class=\"language-js\">function addElement(parent, elementText) {\n  var element = document.createElement('a');\n  element.innerHTML = anchorText;\n  parent.appendChild(element);\n}\n</code></pre>\n<h2>创建多个元素</h2>\n<p>在实际的使用中，更多的情况是创建多个元素，并插入到页面中。按照创建单一元素插入到页面时的写法，我们会这样写：</p>\n<pre><code class=\"language-js\">function addElements(parent, elementText) {\n  var element;\n\n  for (var i = 0; i &#x3C; 10; i++) {\n    element = document.createElement('a');\n    element.innerHTML = anchorText;\n    parent.appendChild(element);\n  }\n}\n</code></pre>\n<p>可以看出，这样写会产生10次回流，每一次插入元素都会产生一次。这时候我们需要用到 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment\">DocumentFragment</a>，DocumentFragment 有占位符的作用，可以暂时存放那些插入文档元素。</p>\n<p>当把一个 DocumentFragment 插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。可以用 <code>Document.createDocumentFragment()</code> 方法创建新的空 DocumentFragment 节点。</p>\n<p>通过 DocumentFragment 可以让上面的操作值产生一次浏览器回流：</p>\n<pre><code class=\"language-js\">function addElements(parent, elementText) {\n  var element,\n      fragment = document.createDocumentFragment();\n\n  for (var i = 0; i &#x3C; 10; i++) {\n    element = document.createElement('a');\n    element.innerHTML = anchorText;\n    fragment.appendChild(element);\n  }\n\n  parent.appendChild(fragment);\n}\n</code></pre>\n<h2>修改元素样式</h2>\n<p>在 JavaScript 中修改元素的样式也是经常会做的操作。修改元素的多个样式时会这样：</p>\n<pre><code class=\"language-js\">function changeStyle(element) {\n  element.style.fontSize   = \"14px\";\n  element.style.fontWeight = \"600\";\n  element.style.color      = \"#fff\";\n}\n</code></pre>\n<p>实际上，每一次对元素的样式的变更都会产生一次回流。好的做法是创建一个 class 包含这些样式。</p>\n<pre><code class=\"language-css\">.changeStyle {\n  font-size: 14px;\n  font-weight: 600;\n  color: #fff;\n}\n</code></pre>\n<pre><code class=\"language-js\">function changeStyle(element) {\n  element.className = 'changeStyle';\n}\n</code></pre>\n<h2>总结</h2>\n<p>减少浏览器回流的方式，就是将一切能够在内存完成的完成之后再应用到页面中，对元素样式的操作尽量通过添加修改 CSS 类来实现。</p>","rawMarkdownBody":"\n## 什么是浏览器回流\n浏览器在显示网页时，需要计算每一个元素应该放置的位置，这个计算过程就称为浏览器回流（browser reflow）。回流会重新计算页面的布局，在回流中会重新计算元素的尺寸与位置，并且也会触发对子元素的回流。\n\n触发浏览器回流的操作：\n- 在 DOM 中插入，移除或者更新元素\n- 修改页面上的内容\n- 移动 DOM 元素\n- 修改元素 CSS 样式\n- 修改元素的类名\n- 调整窗口的大小\n\n<!--more-->\n\n基本上跟元素相关的操作都会触发浏览器回流。浏览器的回流需要耗时，尽量减少浏览器的回流，那么就可以提高整个网页的效率。\n\n## 创建单一元素\n当我们需要创建一个新元素插入到页面中，并且设置元素的属性。我们会这样做：\n\n``` js\nfunction addElement(parent, elementText) {\n  var element = document.createElement('a');\n  parent.appendChild(element);\n  element.innerHTML = anchorText;\n}\n```\n\n这样写会产生2次浏览器回流，新创建的元素在插入页面中之后又进行了属性的修改。更好的写法是把插入到页面的操作放到最后，这样给元素设置属性的操作就是在内存中进行的。这样就只有元素插入到页面时产生的一次回流。\n\n``` js\nfunction addElement(parent, elementText) {\n  var element = document.createElement('a');\n  element.innerHTML = anchorText;\n  parent.appendChild(element);\n}\n```\n\n## 创建多个元素\n在实际的使用中，更多的情况是创建多个元素，并插入到页面中。按照创建单一元素插入到页面时的写法，我们会这样写：\n\n``` js\nfunction addElements(parent, elementText) {\n  var element;\n\n  for (var i = 0; i < 10; i++) {\n    element = document.createElement('a');\n    element.innerHTML = anchorText;\n    parent.appendChild(element);\n  }\n}\n```\n\n可以看出，这样写会产生10次回流，每一次插入元素都会产生一次。这时候我们需要用到 [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment)，DocumentFragment 有占位符的作用，可以暂时存放那些插入文档元素。\n\n当把一个 DocumentFragment 插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。可以用 `Document.createDocumentFragment()` 方法创建新的空 DocumentFragment 节点。\n\n通过 DocumentFragment 可以让上面的操作值产生一次浏览器回流：\n\n``` js\nfunction addElements(parent, elementText) {\n  var element,\n      fragment = document.createDocumentFragment();\n\n  for (var i = 0; i < 10; i++) {\n    element = document.createElement('a');\n    element.innerHTML = anchorText;\n    fragment.appendChild(element);\n  }\n\n  parent.appendChild(fragment);\n}\n```\n## 修改元素样式\n\n在 JavaScript 中修改元素的样式也是经常会做的操作。修改元素的多个样式时会这样：\n\n``` js\nfunction changeStyle(element) {\n  element.style.fontSize   = \"14px\";\n  element.style.fontWeight = \"600\";\n  element.style.color      = \"#fff\";\n}\n```\n\n实际上，每一次对元素的样式的变更都会产生一次回流。好的做法是创建一个 class 包含这些样式。\n\n``` css\n.changeStyle {\n  font-size: 14px;\n  font-weight: 600;\n  color: #fff;\n}\n```\n\n``` js\nfunction changeStyle(element) {\n  element.className = 'changeStyle';\n}\n```\n\n## 总结\n减少浏览器回流的方式，就是将一切能够在内存完成的完成之后再应用到页面中，对元素样式的操作尽量通过添加修改 CSS 类来实现。\n","frontmatter":{"title":"如何减少浏览器回流","date":"2016年8月2日","tags":["JavaScript","前端"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/javascript-reduce-the-browser-reflow/"}}}