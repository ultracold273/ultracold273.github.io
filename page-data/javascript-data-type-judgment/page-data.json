{"componentChunkName":"component---src-templates-post-tsx","path":"/javascript-data-type-judgment/","result":{"data":{"markdownRemark":{"html":"<p>最近开始读之前没有读完的 underscore 的源码，刚把 Object 部分读完。对 JavaScript 中类型判断部分的总结。</p>\n<h2>Object.prototype.toString()</h2>\n<p>在进行类型判断时，使用到最多的当属 <code>Object.prototype.toString()</code>。</p>\n<p><code>toString()</code> 方法返回一个代表该对象的字符串。每个对象都会继承 Object 上的 <code>toString</code> 方法，如果该方法没有被同名方法覆盖的话。使用 <code>toString()</code> 方法将会返回字符串 <code>\"[object type]\"</code>。其中 type 根据对象的类型的不同而不同。</p>\n<p>关于 <code>Object.prototype.toString()</code> 的详细描述可以查看：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\">Object.prototype.toString() - JavaScript | MDN</a></p>\n<!--more-->\n<h2>使用 toString() 判断类型</h2>\n<p>由于 <code>toString()</code> 会返回带有类型信息的字符串，所以通常可以使用它来进行数据类型的判断。</p>\n<p>underscore 中对一些数据类型的判断实现：</p>\n<pre><code class=\"language-js\">_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n  _['is' + name] = function(obj) {\n    return toString.call(obj) === '[object ' + name + ']';\n  };\n});\n</code></pre>\n<p>通过 <code>toString()</code> 函数的返回值判断类型，这里不使用 <code>typeof</code> 判断的原因是字面量与对象的返回值不同。</p>\n<p>例如字符串字面量 <code>\"1\"</code> 通过 <code>typeof</code> 操作符返回的是 <code>\"string\"</code>，而字符串对象 <code>new String('1')</code> 通过 <code>typeof</code> 操作符返回的却是 <code>\"object\"</code>。所以通过 <code>Object.prototype.toString()</code> 来进行判断最为妥当。</p>\n<h2>判断 NaN，null，undefined</h2>\n<h3>NaN</h3>\n<p>在 JavaScript 的 Number 类型中有这样一个特殊的存在，那就是 <code>NaN</code>。<code>NaN</code> 的意思是 Not-A-Number，即不是一个数字。当对无法转换为数字的变量进行数字转换时就会得到 <code>NaN</code>。<code>Nan</code> 还有一个特殊的性质，就是 <code>NaN === NaN</code> 返回的是 false。</p>\n<p>所以对 NaN 的判断的实现如下：</p>\n<pre><code class=\"language-js\">_.isNaN = function(obj) {\n  return _.isNumber(obj) &#x26;&#x26; isNaN(obj);\n};\n</code></pre>\n<p>先判断是否为 Number 类型，排除隐式类型转换造成的误判。再使用 isNaN 函数判断是否为 NaN。</p>\n<h3>null</h3>\n<p>在 JavaScript 中有 <code>==</code> 与 <code>===</code> 两个相等操作符，后者为严格比较。<code>null == undefined</code> 的返回值是 true，所以不能使用这个来判断是否为 null。而 <code>null === undefined</code> 返回的是 false，因此使用严格相等哎判断是否为 null。而</p>\n<pre><code class=\"language-js\">_.isNull = function(obj) {\n  return obj === null;\n};\n</code></pre>\n<h3>undefined</h3>\n<p>判断变量是否为 <code>undefined</code>，很自然会想到使用 <code>foo === undefined</code> 的方式来判断。但是这样做是不安全的，在旧的浏览器版本上 <code>undefined</code> 是可以被重写的。这时使用上面那样判断会出现这种状况：</p>\n<pre><code class=\"language-js\">undefined = 'foo';\nvar foo = 'foo';\n\nconsole.log(foo === undefined); // true\n</code></pre>\n<p>所以这种判断方式不被推荐，即使新版本的浏览器上无法重写 undefined。更推荐的方式是使用 <code>void 0</code> 来判断。\n关于 <code>void 0</code> 与 <code>undefined</code> 可以参考我在知乎上的回答：<a href=\"https://www.zhihu.com/question/52645620/answer/131470539\">（void 0）在javascript中表示什么，和undefined有什么区别？</a></p>\n<p>推荐的 undefined 判断实现：</p>\n<pre><code class=\"language-js\">_.isUndefined = function(obj) {\n  return obj === void 0;\n};\n</code></pre>\n<h2>判断 Object</h2>\n<p>在 underscore 中对对象类型的判断是通过 <code>typeof</code> 来实现的：</p>\n<pre><code class=\"language-js\">_.isObject = function(obj) {\n  var type = typeof obj;\n  return type === 'function' || type === 'object' &#x26;&#x26; !!obj;\n};\n</code></pre>\n<p><code>typeof</code> 操作符在变量为 <code>null</code> 或者是对象时返回 <code>\"object\"</code>，在变量为函数对象时返回 <code>function</code>。</p>\n<p>我们需要的是判断变量是否为对象，那么就需要排除 <code>null</code> 的情况，即将变量进行两次取反操作，将变量转换为 <code>Boolean</code> 类型。由于 <code>null</code> 会转换为 <code>false</code>，那么这样就可以排除 <code>null</code> 的干扰。</p>","rawMarkdownBody":"\n最近开始读之前没有读完的 underscore 的源码，刚把 Object 部分读完。对 JavaScript 中类型判断部分的总结。\n\n## Object.prototype.toString()\n在进行类型判断时，使用到最多的当属 `Object.prototype.toString()`。\n\n`toString()` 方法返回一个代表该对象的字符串。每个对象都会继承 Object 上的 `toString` 方法，如果该方法没有被同名方法覆盖的话。使用 `toString()` 方法将会返回字符串 `\"[object type]\"`。其中 type 根据对象的类型的不同而不同。\n\n关于 `Object.prototype.toString()` 的详细描述可以查看：[Object.prototype.toString() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString)\n\n<!--more-->\n\n## 使用 toString() 判断类型\n由于 `toString()` 会返回带有类型信息的字符串，所以通常可以使用它来进行数据类型的判断。\n\nunderscore 中对一些数据类型的判断实现：\n\n```js\n_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n  _['is' + name] = function(obj) {\n    return toString.call(obj) === '[object ' + name + ']';\n  };\n});\n```\n\n通过 `toString()` 函数的返回值判断类型，这里不使用 `typeof` 判断的原因是字面量与对象的返回值不同。\n\n例如字符串字面量 `\"1\"` 通过 `typeof` 操作符返回的是 `\"string\"`，而字符串对象 `new String('1')` 通过 `typeof` 操作符返回的却是 `\"object\"`。所以通过 `Object.prototype.toString()` 来进行判断最为妥当。\n\n## 判断 NaN，null，undefined\n\n### NaN\n在 JavaScript 的 Number 类型中有这样一个特殊的存在，那就是 `NaN`。`NaN` 的意思是 Not-A-Number，即不是一个数字。当对无法转换为数字的变量进行数字转换时就会得到 `NaN`。`Nan` 还有一个特殊的性质，就是 `NaN === NaN` 返回的是 false。\n\n所以对 NaN 的判断的实现如下：\n\n``` js\n_.isNaN = function(obj) {\n  return _.isNumber(obj) && isNaN(obj);\n};\n```\n\n先判断是否为 Number 类型，排除隐式类型转换造成的误判。再使用 isNaN 函数判断是否为 NaN。\n\n### null\n在 JavaScript 中有 `==` 与 `===` 两个相等操作符，后者为严格比较。`null == undefined` 的返回值是 true，所以不能使用这个来判断是否为 null。而 `null === undefined` 返回的是 false，因此使用严格相等哎判断是否为 null。而\n\n``` js\n_.isNull = function(obj) {\n  return obj === null;\n};\n```\n\n### undefined\n判断变量是否为 `undefined`，很自然会想到使用 `foo === undefined` 的方式来判断。但是这样做是不安全的，在旧的浏览器版本上 `undefined` 是可以被重写的。这时使用上面那样判断会出现这种状况：\n\n``` js\nundefined = 'foo';\nvar foo = 'foo';\n\nconsole.log(foo === undefined); // true\n```\n\n所以这种判断方式不被推荐，即使新版本的浏览器上无法重写 undefined。更推荐的方式是使用 `void 0` 来判断。\n关于 `void 0` 与 `undefined` 可以参考我在知乎上的回答：[（void 0）在javascript中表示什么，和undefined有什么区别？](https://www.zhihu.com/question/52645620/answer/131470539)\n\n推荐的 undefined 判断实现：\n\n``` js\n_.isUndefined = function(obj) {\n  return obj === void 0;\n};\n```\n\n## 判断 Object\n在 underscore 中对对象类型的判断是通过 `typeof` 来实现的：\n\n``` js\n_.isObject = function(obj) {\n  var type = typeof obj;\n  return type === 'function' || type === 'object' && !!obj;\n};\n```\n\n`typeof` 操作符在变量为 `null` 或者是对象时返回 `\"object\"`，在变量为函数对象时返回 `function`。\n\n我们需要的是判断变量是否为对象，那么就需要排除 `null` 的情况，即将变量进行两次取反操作，将变量转换为 `Boolean` 类型。由于 `null` 会转换为 `false`，那么这样就可以排除 `null` 的干扰。\n","frontmatter":{"title":"JavaScript 数据类型判断","date":"2016年11月21日","tags":["JavaScript","前端"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/javascript-data-type-judgment/"}}}