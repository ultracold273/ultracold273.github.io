{"componentChunkName":"component---src-templates-post-tsx","path":"/redux-source-code-insight/","result":{"data":{"markdownRemark":{"html":"<h2>三大原则</h2>\n<ul>\n<li>单一数据源（store）</li>\n<li>state 只可读（只能通过 Reducer 生成新 State）</li>\n<li>使用纯函数执行修改（Reducer 必须为纯函数，无副作用）</li>\n</ul>\n<!--more-->\n<h2>单向数据流</h2>\n<ul>\n<li><code>dispatch</code> 触发 action 传递数据，但应该尽量减少传递的数据</li>\n<li>如果有 middleware，在 action 发起之后，到达 reducer 之前执行</li>\n<li>到达 reducer 之后，根据 action type 返回新 state</li>\n</ul>\n<h2>源码解析</h2>\n<p>Redux 提供的 API 主要有：</p>\n<ul>\n<li><code>createStore</code>: 创建 store 以及提供相关操作</li>\n<li><code>combineReducers</code>: 合并不同的 reducer 函数</li>\n<li><code>applyMiddleware</code>: 添加 Redux 中间件</li>\n<li><code>bindActionCreators</code>: bind action 到组件中</li>\n</ul>\n<h3>createStore</h3>\n<p><code>createStore</code> 用来创建 Redux store，用于存放所有的 state。</p>\n<p>通过 <code>const store = createStore(reducer, initialState)</code> 创建 store，只能通过 dispatch action 的方式来改变 state。同时提供了 <code>getState</code>，<code>subscribe</code> 等方法。</p>\n<pre><code class=\"language-js\">export default function createStore(reducer, preloadedState, enhancer) {\n  // ...\n\n  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  let nextListeners = currentListeners\n  let isDispatching = false\n\n  // ...\n\n  dispatch({ type: ActionTypes.INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n</code></pre>\n<p>当使用 <code>createStore</code> 方法时，<code>dispatch</code> 了名为 <code>@@redux/INIT</code> 的 action。表示已经初始化了 store。</p>\n<p><code>dispatch</code> 方法的实现：</p>\n<pre><code class=\"language-js\">  function dispatch(action) {\n    // ...\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n\n    const listeners = currentListeners = nextListeners\n    for (let i = 0; i &#x3C; listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n</code></pre>\n<p><code>currentState = currentReducer(currentState, action)</code> 执行 action 对应的 reducer 操作产生新的 state，如果有监听函数的话，按顺序触发监听函数。</p>\n<p>监听函数由 <code>subscribe</code> 方法添加，<code>subscribe</code> 方法的返回一个 <code>unsubscribe</code> 函数，用来取消监听。</p>\n<p><code>subscribe</code> 方法的具体实现:</p>\n<pre><code class=\"language-js\">function subscribe(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Expected listener to be a function.')\n  }\n\n  let isSubscribed = true\n\n  ensureCanMutateNextListeners()\n  nextListeners.push(listener)\n\n  return function unsubscribe() {\n    if (!isSubscribed) {\n      return\n    }\n\n    isSubscribed = false\n\n    ensureCanMutateNextListeners()\n    const index = nextListeners.indexOf(listener)\n    nextListeners.splice(index, 1)\n  }\n}\n</code></pre>\n<p>实际上 <code>subscribe</code> 仅是在 <code>nextListeners</code> 中添加想要执行的监听函数，并返回了用于删除该函数的 <code>unsubscribe</code> 方法</p>\n<h3>combineReducers</h3>\n<p><code>combineReducers</code> 用于合并不同的 reducer 函数，返回唯一的一个 reducer 函数供 <code>createStore</code> 使用</p>\n<pre><code class=\"language-js\">export default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n  for (let i = 0; i &#x3C; reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    // ...\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // ...\n\n  return function combination(state = {}, action) {\n    // ...\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i &#x3C; finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      // ...\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n  }\n}\n</code></pre>\n<p>首先处理传入的 reducer 对象（包含不同的 reducer 函数），得到键值为 function 类型的对象 <code>finalReducers</code> 与一个包含其键的数组 <code>finalReducerKeys</code>。</p>\n<p><code>combineReducers</code> 返回一个 <code>reducers</code> 函数用于处理 action，循环所有的 reducers 传入 action 进行处理，当 state 不变时，返回原来的 state</p>\n<h3>applyMiddleware</h3>\n<p><code>applyMiddleware</code> 的作用是添加中间件并执行中间件，主要是通过 <code>compose</code> 函数将所有的中间件串起来</p>\n<pre><code class=\"language-js\">export default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n</code></pre>\n<p>重点是 <code>funcs.reduce((a, b) => (...args) => a(b(...args)))</code> ，通过函数式编程中常见的 <code>f(g(args))</code> 形式串起来，返回一个函数，函数由内到外执行传入之前传入的函数数组，函数的参数将会传递到第一个执行的函数中。</p>\n<p>简单的例子：</p>\n<pre><code class=\"language-js\">var f1 = function(a) {\n    console.log('f1: '+ a)\n    return a * 10\n}\n\nvar f2 = function(a) {\n    console.log('f2: ' + a)\n    return a + 1\n}\nconst funcs = [f1, f2]\n\nconst func = funcs.reduce((a, b) => (...args) => a(b(...args)))\nfunc(1)\n</code></pre>\n<p><img src=\"https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/6vttf.jpg\" alt=\"compose\"></p>\n<p>在 applyMiddleware 中 <code>dispatch = compose(...chain)(store.dispatch)</code>，即传入 compose 返回的函数的参数为 store 原来的 dispatch 函数。</p>\n<p>也就是说，添加了中间件后，执行 dispatch 函数将会首先依次执行传入的中间件, 最后再执行原先的 <code>store.dispatch</code></p>\n<p>关于 Redux midddleware 有篇文章写得很不错：<a href=\"https://github.com/asd0102433/blog/issues/1\">compose and middleware 源码分析</a></p>\n<h3>bindActionCreators</h3>\n<p><code>bindActionCreators</code> 方法说白了就是把 action creators 转成拥有同名 keys 的对象，并使用 dispatch 将对象包裹起来，从而能够直接调用函数 dispatch action</p>\n<pre><code class=\"language-js\">function bindActionCreator(actionCreator, dispatch) {\n  return (...args) => dispatch(actionCreator(...args))\n}\n\nexport default function bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  // ...\n\n  const keys = Object.keys(actionCreators)\n  const boundActionCreators = {}\n  for (let i = 0; i &#x3C; keys.length; i++) {\n    const key = keys[i]\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  return boundActionCreators\n}\n</code></pre>\n<p>这部分得源码很简单，只是简单的判断 actionCreators，是对象的话就返回一个键值为绑定了 dispatch 的函数的对象</p>\n<h3>思考总结</h3>\n<p>很久之前就学会了 Redux 的『使用』，但是却不明白到底是什么实现的，只知道应该那样使用。</p>\n<p>阅读了源码之后对 Redux 整个流程更加清晰，有利于之后的使用。也更加理解 Redux 单向数据流的这种思想，虽然使用上更加繁琐，但是如果数据复杂起来，这种单向数据流的管理方式还是利大于弊的。</p>\n<p><strong>参考链接</strong></p>\n<ul>\n<li><a href=\"http://cn.redux.js.org/index.html\">Redux 中文文档</a></li>\n<li><a href=\"https://github.com/asd0102433/blog/issues/1\">compose and middleware 源码分析</a></li>\n</ul>","rawMarkdownBody":"\n## 三大原则\n- 单一数据源（store）\n- state 只可读（只能通过 Reducer 生成新 State）\n- 使用纯函数执行修改（Reducer 必须为纯函数，无副作用）\n\n<!--more-->\n\n## 单向数据流\n- `dispatch` 触发 action 传递数据，但应该尽量减少传递的数据\n- 如果有 middleware，在 action 发起之后，到达 reducer 之前执行\n- 到达 reducer 之后，根据 action type 返回新 state\n\n## 源码解析\nRedux 提供的 API 主要有：\n- `createStore`: 创建 store 以及提供相关操作\n- `combineReducers`: 合并不同的 reducer 函数\n- `applyMiddleware`: 添加 Redux 中间件\n- `bindActionCreators`: bind action 到组件中\n\n### createStore\n`createStore` 用来创建 Redux store，用于存放所有的 state。\n\n通过 `const store = createStore(reducer, initialState)` 创建 store，只能通过 dispatch action 的方式来改变 state。同时提供了 `getState`，`subscribe` 等方法。\n\n```js\nexport default function createStore(reducer, preloadedState, enhancer) {\n  // ...\n\n  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  let nextListeners = currentListeners\n  let isDispatching = false\n\n  // ...\n\n  dispatch({ type: ActionTypes.INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n```\n\n当使用 `createStore` 方法时，`dispatch` 了名为 `@@redux/INIT` 的 action。表示已经初始化了 store。\n\n`dispatch` 方法的实现：\n```js\n  function dispatch(action) {\n    // ...\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n\n    const listeners = currentListeners = nextListeners\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n```\n\n`currentState = currentReducer(currentState, action)` 执行 action 对应的 reducer 操作产生新的 state，如果有监听函数的话，按顺序触发监听函数。\n\n监听函数由 `subscribe` 方法添加，`subscribe` 方法的返回一个 `unsubscribe` 函数，用来取消监听。\n\n`subscribe` 方法的具体实现:\n```js\nfunction subscribe(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Expected listener to be a function.')\n  }\n\n  let isSubscribed = true\n\n  ensureCanMutateNextListeners()\n  nextListeners.push(listener)\n\n  return function unsubscribe() {\n    if (!isSubscribed) {\n      return\n    }\n\n    isSubscribed = false\n\n    ensureCanMutateNextListeners()\n    const index = nextListeners.indexOf(listener)\n    nextListeners.splice(index, 1)\n  }\n}\n```\n\n实际上 `subscribe` 仅是在 `nextListeners` 中添加想要执行的监听函数，并返回了用于删除该函数的 `unsubscribe` 方法\n\n\n### combineReducers\n`combineReducers` 用于合并不同的 reducer 函数，返回唯一的一个 reducer 函数供 `createStore` 使用\n\n```js\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n\t// ...\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // ...\n\n  return function combination(state = {}, action) {\n    // ...\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n\t  // ...\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n  }\n}\n```\n\n首先处理传入的 reducer 对象（包含不同的 reducer 函数），得到键值为 function 类型的对象 `finalReducers` 与一个包含其键的数组 `finalReducerKeys`。\n\n`combineReducers` 返回一个 `reducers` 函数用于处理 action，循环所有的 reducers 传入 action 进行处理，当 state 不变时，返回原来的 state\n\n### applyMiddleware\n`applyMiddleware` 的作用是添加中间件并执行中间件，主要是通过 `compose` 函数将所有的中间件串起来\n\n```js\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n重点是 `funcs.reduce((a, b) => (...args) => a(b(...args)))` ，通过函数式编程中常见的 `f(g(args))` 形式串起来，返回一个函数，函数由内到外执行传入之前传入的函数数组，函数的参数将会传递到第一个执行的函数中。\n\n简单的例子：\n```js\nvar f1 = function(a) {\n\tconsole.log('f1: '+ a)\n\treturn a * 10\n}\n\nvar f2 = function(a) {\n\tconsole.log('f2: ' + a)\n\treturn a + 1\n}\nconst funcs = [f1, f2]\n\nconst func = funcs.reduce((a, b) => (...args) => a(b(...args)))\nfunc(1)\n```\n![compose](https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/6vttf.jpg)\n\n在 applyMiddleware 中 `dispatch = compose(...chain)(store.dispatch)`，即传入 compose 返回的函数的参数为 store 原来的 dispatch 函数。\n\n也就是说，添加了中间件后，执行 dispatch 函数将会首先依次执行传入的中间件, 最后再执行原先的 `store.dispatch`\n\n关于 Redux midddleware 有篇文章写得很不错：[compose and middleware 源码分析](https://github.com/asd0102433/blog/issues/1)\n\n### bindActionCreators\n`bindActionCreators` 方法说白了就是把 action creators 转成拥有同名 keys 的对象，并使用 dispatch 将对象包裹起来，从而能够直接调用函数 dispatch action\n\n```js\nfunction bindActionCreator(actionCreator, dispatch) {\n  return (...args) => dispatch(actionCreator(...args))\n}\n\nexport default function bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  // ...\n\n  const keys = Object.keys(actionCreators)\n  const boundActionCreators = {}\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  return boundActionCreators\n}\n```\n\n这部分得源码很简单，只是简单的判断 actionCreators，是对象的话就返回一个键值为绑定了 dispatch 的函数的对象\n\n### 思考总结\n很久之前就学会了 Redux 的『使用』，但是却不明白到底是什么实现的，只知道应该那样使用。\n\n阅读了源码之后对 Redux 整个流程更加清晰，有利于之后的使用。也更加理解 Redux 单向数据流的这种思想，虽然使用上更加繁琐，但是如果数据复杂起来，这种单向数据流的管理方式还是利大于弊的。\n\n**参考链接**\n- [Redux 中文文档](http://cn.redux.js.org/index.html)\n- [compose and middleware 源码分析](https://github.com/asd0102433/blog/issues/1)\n","frontmatter":{"title":"Redux 源码解析","date":"2017年7月4日","tags":["Redux","React","JavaScript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/redux-source-code-insight/"}}}