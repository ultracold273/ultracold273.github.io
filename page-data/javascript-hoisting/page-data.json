{"componentChunkName":"component---src-templates-post-tsx","path":"/javascript-hoisting/","result":{"data":{"markdownRemark":{"html":"<h2>变量提升</h2>\n<h3>合乎常理的预期</h3>\n<p>按照合乎常理的预期，程序应该是由上至下一行一行执行的，如果使用了之前没有定义的变量的话，正确的反应应该是会报错，就象下面这段 C++ 代码：</p>\n<pre><code class=\"language-cpp\">#include &#x3C;cstdio>\nusing namespace std;\n\nint main() {\n  printf(\"%d\\n\", &#x26;n);  // Error\n\n  int n = 2;\n}\n</code></pre>\n<!--more-->\n<h3>并不完全正确</h3>\n<p>实际上合乎常理的预期并不是“完全正确”的，在 JavaScript 中并不符合直觉。</p>\n<p>例如这段 JavaScript 代码：</p>\n<pre><code class=\"language-js\">console.log(n);\n\nvar n = 2；\n</code></pre>\n<p>讲道理，就直觉来说这段代码应该是会报错的。但是 JavaScript 却不是像往常的其他编程语言一样报错，而是输出 undefined。</p>\n<p>先把问题留着，再看看另一段代码。</p>\n<pre><code class=\"language-js\">var n;\n\nconsole.log(n);\n\nn = 2;\n</code></pre>\n<p>这段代码的输出同样也是 undefined，实际上这两段代码在编译器上是没有差别的，第一段代码实际上是按照第二段代码那样执行的。就像是变量的声明部分从原来的位置移动到了当前作用域最顶部，这个过程就叫作 <strong>提升</strong>。只有声明本身会被提升，而赋值操作依旧会留着原地。</p>\n<h2>函数提升</h2>\n<p>函数在声明时也会像变量一样被提升。但是不同的是，函数表达式不会被提升。</p>\n<h3>函数声明</h3>\n<p>函数声明提升：</p>\n<pre><code class=\"language-js\">foo();\n\nfunction foo() {\n  console.log(n);\n  var n = 2;\n}\n</code></pre>\n<p>实际上代码将会按照下面的形式执行：</p>\n<pre><code class=\"language-js\">function foo() {\n  var n;\n  console.log(n);\n  n = 2;\n}\n\nfoo(); // undefined\n</code></pre>\n<p>函数 <code>foo</code> 的作用域内的变量 <code>n</code> 提升到了作用域的顶部，全局作用域里的 <code>foo</code> 函数声明也会被提前到所处的作用域顶部，即全局作用域的顶部。但是函数表达式的话只有变量被声明，但是赋值给变量的函数不会被提升。</p>\n<h3>函数表达式</h3>\n<p>函数表达式不会被提升：</p>\n<pre><code class=\"language-js\">foo();\n\nvar foo = function bar() {\n  // do something\n}\n</code></pre>\n<p>函数表达式的提升类似与变量的提升：</p>\n<pre><code class=\"language-js\">var foo;\n\nfoo(); // TypeError\n\nfoo = function bar() {\n  // do something\n}\n</code></pre>\n<p>这样会引发 <code>TypeError</code> 异常，因为当时的 <code>foo</code> 并没有赋值，对 <code>undefined</code> 进行函数调用会导致非法操作抛出异常。</p>\n<h3>函数优先</h3>\n<p>函数会首先被提升，然后跟着才是变量。也就是说同时存在函数声明与函数表达式时，函数声明会优先于函数表达式提升。</p>\n<pre><code class=\"language-js\">foo();\n\nfunction foo() {\n  console.log('1');\n}\n\nvar foo = function () {\n  console.log('2');\n}\n</code></pre>\n<p>上面的代码将会被理解成下面的形式：</p>\n<pre><code class=\"language-js\">function foo() {\n  console.log('1');\n}\n\nvar foo;\n\nfoo(); // 1\n\nfoo = function () {\n  console.log('2');\n}\n</code></pre>\n<p>所以实际上的输出是 1，因为函数表达式的赋值操作会在原来的位置，而声明操作则是提升到作用域顶部，但是优先级低于函数声明。</p>\n<p>重复声明同名变量在 JavaScript 非严格模式中将会被忽略，所以实际上函数表达式的位置并没有改变。</p>","rawMarkdownBody":"\n## 变量提升\n\n### 合乎常理的预期\n按照合乎常理的预期，程序应该是由上至下一行一行执行的，如果使用了之前没有定义的变量的话，正确的反应应该是会报错，就象下面这段 C++ 代码：\n```cpp\n#include <cstdio>\nusing namespace std;\n\nint main() {\n  printf(\"%d\\n\", &n);  // Error\n\n  int n = 2;\n}\n```\n<!--more-->\n\n### 并不完全正确\n实际上合乎常理的预期并不是“完全正确”的，在 JavaScript 中并不符合直觉。\n\n例如这段 JavaScript 代码：\n\n```js\nconsole.log(n);\n\nvar n = 2；\n```\n\n讲道理，就直觉来说这段代码应该是会报错的。但是 JavaScript 却不是像往常的其他编程语言一样报错，而是输出 undefined。\n\n先把问题留着，再看看另一段代码。\n\n```js\nvar n;\n\nconsole.log(n);\n\nn = 2;\n```\n\n这段代码的输出同样也是 undefined，实际上这两段代码在编译器上是没有差别的，第一段代码实际上是按照第二段代码那样执行的。就像是变量的声明部分从原来的位置移动到了当前作用域最顶部，这个过程就叫作 **提升**。只有声明本身会被提升，而赋值操作依旧会留着原地。\n\n## 函数提升\n\n函数在声明时也会像变量一样被提升。但是不同的是，函数表达式不会被提升。\n\n### 函数声明\n\n函数声明提升：\n```js\nfoo();\n\nfunction foo() {\n  console.log(n);\n  var n = 2;\n}\n```\n\n实际上代码将会按照下面的形式执行：\n```js\nfunction foo() {\n  var n;\n  console.log(n);\n  n = 2;\n}\n\nfoo(); // undefined\n```\n\n函数 `foo` 的作用域内的变量 `n` 提升到了作用域的顶部，全局作用域里的 `foo` 函数声明也会被提前到所处的作用域顶部，即全局作用域的顶部。但是函数表达式的话只有变量被声明，但是赋值给变量的函数不会被提升。\n\n### 函数表达式\n\n函数表达式不会被提升：\n```js\nfoo();\n\nvar foo = function bar() {\n  // do something\n}\n```\n\n函数表达式的提升类似与变量的提升：\n```js\nvar foo;\n\nfoo(); // TypeError\n\nfoo = function bar() {\n  // do something\n}\n```\n\n这样会引发 `TypeError` 异常，因为当时的 `foo` 并没有赋值，对 `undefined` 进行函数调用会导致非法操作抛出异常。\n\n### 函数优先\n函数会首先被提升，然后跟着才是变量。也就是说同时存在函数声明与函数表达式时，函数声明会优先于函数表达式提升。\n\n```js\nfoo();\n\nfunction foo() {\n  console.log('1');\n}\n\nvar foo = function () {\n  console.log('2');\n}\n```\n\n上面的代码将会被理解成下面的形式：\n```js\nfunction foo() {\n  console.log('1');\n}\n\nvar foo;\n\nfoo(); // 1\n\nfoo = function () {\n  console.log('2');\n}\n```\n\n所以实际上的输出是 1，因为函数表达式的赋值操作会在原来的位置，而声明操作则是提升到作用域顶部，但是优先级低于函数声明。\n\n重复声明同名变量在 JavaScript 非严格模式中将会被忽略，所以实际上函数表达式的位置并没有改变。\n","frontmatter":{"title":"不合常理的变量提升","date":"2016年4月28日","tags":["JavaScript","前端"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/javascript-hoisting/"}}}