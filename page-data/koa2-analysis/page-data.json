{"componentChunkName":"component---src-templates-post-tsx","path":"/koa2-analysis/","result":{"data":{"markdownRemark":{"html":"<h2>源码结构</h2>\n<p>Koa 的源码中主要为 <code>lib</code> 目录下的 <code>application.js</code>、<code>context.js</code>、<code>request.js</code> 与 <code>response.js</code> 文件</p>\n<!--more-->\n<pre><code>.\n├── AUTHORS\n├── CODE_OF_CONDUCT.md\n├── History.md\n├── LICENSE\n├── Makefile\n├── Readme.md\n├── benchmarks\n├── docs\n├── lib\n│   ├── application.js\n│   ├── context.js\n│   ├── request.js\n│   └── response.js\n├── package.json\n└── test\n</code></pre>\n<p><strong>application.js</strong>: 框架入口，导出 Application 类，即使用时导入的 Koa 类</p>\n<p><strong>context.js</strong>: context 对象的原型，代理 request 与 response 对象</p>\n<p><strong>request.js</strong>:  request 对象的原型，提供请求相关的数据与操作</p>\n<p><strong>response.js</strong>: response 对象的原型，提供响应相关的数据与操作</p>\n<h2>Application</h2>\n<p>application.js 是 Koa 框架的入口，导出 Application 类来用于创建 app 对象。</p>\n<pre><code class=\"language-js\">const Koa = require('koa'); // 导入 Koa, 即导入 Application 类\nconst app = new Koa(); // 创建 Application 类的实例\n</code></pre>\n<p>Application 继承于 EventEmitter 类，使得 Koa 能够监听事件。</p>\n<h2>构造函数</h2>\n<p>Application 类包含了以下属性：</p>\n<ul>\n<li><strong>proxy</strong>: 是否信任 proxy header 参数，默认为 false</li>\n<li><strong>middleware</strong>: 保存通过 <code>app.use(middleware)</code> 注册的中间件</li>\n<li><strong>subdomainOffset</strong>: 子域默认偏移量，默认为 2</li>\n<li><strong>env</strong>: 环境参数，默认为 NODE_ENV 或 'development'</li>\n<li><strong>context</strong>: context 模块，通过 <code>context.js</code> 创建</li>\n<li><strong>request</strong>: request 模块，通过 <code>request.js</code> 创建</li>\n<li><strong>response</strong>: response 模块，通过 <code>response.js</code> 创建</li>\n</ul>\n<h2>Application#listen</h2>\n<p>Koa 通过 <code>app.listen(port)</code> 函数在某个端口启动服务。</p>\n<p>listen 函数通过 http 模块开启服务：</p>\n<pre><code class=\"language-js\">/**\n * Shorthand for:\n *\n *    http.createServer(app.callback()).listen(...)\n *\n * @param {Mixed} ...\n * @return {Server}\n * @api public\n */\n\nlisten(...args) {\n  debug('listen');\n  const server = http.createServer(this.callback());\n  return server.listen(...args);\n}\n</code></pre>\n<p>实际上 <code>app.listen()</code>为 <code>http.createServer(app.callback()).listen(...)</code>的速记写法。</p>\n<p><code>http.createServer()</code>用于创建 Web 服务器，接受一个请求监听函数，并在得到请求时执行。</p>\n<p><code>app.callback()</code>用于处理请求，合并中间件与创建请求上下文对象等。</p>\n<h3>Application#use</h3>\n<p>Koa 通过 <code>app.use()</code>添加中间件，并将中间件储存在 <code>app.middleware</code>中。</p>\n<p>在执行 <code>app.callback()</code>时会将 <code>app.middleware</code> 中的中间件合并为一个函数。</p>\n<pre><code class=\"language-js\">/**\n * Use the given middleware `fn`.\n *\n * Old-style middleware will be converted.\n *\n * @param {Function} fn\n * @return {Application} self\n * @api public\n */\n\nuse(fn) {\n  if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n  if (isGeneratorFunction(fn)) {\n    deprecate('Support for generators will be removed in v3. ' +\n              'See the documentation for examples of how to convert old middleware ' +\n              'https://github.com/koajs/koa/blob/master/docs/migration.md');\n    fn = convert(fn);\n  }\n  debug('use %s', fn._name || fn.name || '-');\n  this.middleware.push(fn);\n  return this;\n}\n</code></pre>\n<p>Koa1.x 版本使用 Generator Function 的方式写中间件，而 Koa2 改用 ES6 async/await。</p>\n<p>所以在 <code>use()</code> 函数中会判断是否为旧风格的中间件写法，并对旧风格写法的中间件进行转换（使用 <a href=\"https://github.com/koajs/convert\">koa-convert</a> 进行转换）。</p>\n<p>可以注意到这里 <code>use()</code> 函数返回了 this，这使得在添加中间件的时候能够链式调用。</p>\n<pre><code class=\"language-js\">app\n  .use(function (ctx, next) {\n    // do some thing\n  })\n  .use(function (ctx, next) {\n    // do some thing\n  })\n  // ...\n</code></pre>\n<h3>Application#callback</h3>\n<p><code>app.callback()</code>负责合并中间件，创建请求上下文对象以及返回请求处理函数等。</p>\n<pre><code class=\"language-js\">  /**\n   * Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public\n   */\n\n  callback() {\n    const fn = compose(this.middleware);\n\n    if (!this.listeners('error').length) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      res.statusCode = 404;\n      const ctx = this.createContext(req, res);\n      const onerror = err => ctx.onerror(err);\n      const handleResponse = () => respond(ctx);\n      onFinished(res, onerror);\n      return fn(ctx).then(handleResponse).catch(onerror);\n    };\n\n    return handleRequest;\n  }\n</code></pre>\n<p>通过 <code>compose</code> 函数（<a href=\"https://github.com/koajs/compose\">koa-compose</a>）合并 <code>app.middleware</code>中的所有中间件。<a href=\"/koa/compose.md\">查看</a>关于 koa-compose 的分析。</p>\n<p><code>app.callback()</code> 函数最后返回一个请求处理函数 <code>handleRequest</code>。该函数即为<code>http.createServer</code> 接收的请求处理函数，在得到请求时执行。</p>\n<h4>handleRequest</h4>\n<p><code>handleRequest</code>函数首先将响应状态码默认设置为 404，接着通过 <code>app.createContext()</code>创建请求的上下文对象。</p>\n<p><code>onFinished(res, onerror)</code>通过第三方库 <a href=\"https://github.com/jshttp/on-finished\">on-finished</a> 监听 http response，当请求结束时执行回调。</p>\n<p>这里传入的回调是 <code>context.onerror(err)</code>，即当错误发生时才执行。</p>\n<p>最后返回 <code>fn(ctx).then(handleResponse).catch(onerror)</code>，即将所有中间件执行（传入请求上下文对象 ctx），之后执行响应处理函数（<code>app.respond(ctx)</code>），当抛出异常时同样使用 <code>cintext.onerror(err)</code>处理。</p>\n<h4>createContext</h4>\n<p>app.createContext() 用来创建请求上下文对象，并代理 Koa 的 request 和 response 模块。</p>\n<pre><code class=\"language-js\">/**\n * Initialize a new context.\n *\n * @api private\n */\n\ncreateContext(req, res) {\n  const context = Object.create(this.context);\n  const request = context.request = Object.create(this.request);\n  const response = context.response = Object.create(this.response);\n  context.app = request.app = response.app = this;\n  context.req = request.req = response.req = req;\n  context.res = request.res = response.res = res;\n  request.ctx = response.ctx = context;\n  request.response = response;\n  response.request = request;\n  context.originalUrl = request.originalUrl = req.url;\n  context.cookies = new Cookies(req, res, {\n    keys: this.keys,\n    secure: request.secure\n  });\n  request.ip = request.ips[0] || req.socket.remoteAddress || '';\n  context.accept = request.accept = accepts(req);\n  context.state = {};\n  return context;\n}\n</code></pre>\n<p>这里对请求都对应在上下文对象中添加对应的 cookies。</p>\n<h4>respond</h4>\n<p><code>app.respond(ctx)</code> 函数，也就是 <code>app.createContext()</code>函数中的 <code>handleResponse</code>。在所有中间件执行完之后执行。</p>\n<p>在 koa 中可以通过设置 <code>ctx.respond = false</code>来跳过这个函数，但不推荐这样做。另外，当上下文对象不可写时也会退出该函数：</p>\n<pre><code class=\"language-js\">if (false === ctx.respond) return;\n// ...\nif (!ctx.writable) return;\n</code></pre>\n<p>当返回的状态码表示没有响应主体时，将响应主体置空：</p>\n<pre><code class=\"language-js\">// ignore body\nif (statuses.empty[code]) {\n  // strip headers\n  ctx.body = null;\n  return res.end();\n}\n</code></pre>\n<p>当请求方法为 HEAD 时，判断响应头是否发送以及响应主体是否为 JSON 格式，若满足则设置响应 Content-Length：</p>\n<pre><code class=\"language-js\">if ('HEAD' == ctx.method) {\n  if (!res.headersSent &#x26;&#x26; isJSON(body)) {\n    ctx.length = Buffer.byteLength(JSON.stringify(body));\n  }\n  return res.end();\n}\n</code></pre>\n<p>当返回的状态码表示有响应主体，但响应主体为空时，将响应主体设置为响应信息或状态码。并当响应头未发送时设置 Content-Type 与 Content-Length：</p>\n<pre><code class=\"language-js\">if (null == body) {\n  body = ctx.message || String(code);\n  if (!res.headersSent) {\n    ctx.type = 'text';\n    ctx.length = Buffer.byteLength(body);\n  }\n  return res.end(body);\n}\n</code></pre>\n<p>最后，对不同的响应主体进行处理：</p>\n<pre><code class=\"language-js\">// responses\nif (Buffer.isBuffer(body)) return res.end(body);\nif ('string' == typeof body) return res.end(body);\nif (body instanceof Stream) return body.pipe(res);\n\n// body: json\nbody = JSON.stringify(body);\nif (!res.headersSent) {\n  ctx.length = Buffer.byteLength(body);\n}\nres.end(body);\n</code></pre>\n<h2>Compose</h2>\n<p>在 application.js 中，<code>callback()</code>函数通过 <code>koa-compose</code> 组合所有的中间件，组合成单个函数。</p>\n<p>koa-compose  的实现很简单：</p>\n<pre><code class=\"language-js\">function compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &#x3C;= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n</code></pre>\n<p>首先判断了传入得中间件参数是否为数组，并检查且数组的元素是否为函数，然后返回了一个将中间件组合起来的函数。</p>\n<p>重点关注返回的函数中的<code>dispatch(i)</code>函数，这个函数将获取第一个中间件，并在返回的 Promise 中执行。当中间件<code>await next()</code>时执行下一个中间件，即 <code>dispatch(i + 1)</code>。</p>\n<p>执行流程可以简单看作：</p>\n<pre><code class=\"language-js\">async function middleware1() {\n    console.log('middleware1 begin');\n    await middleware2();\n    console.log('middleware1 end');\n}\n\nasync function middleware2() {\n    console.log('middleware2 begin');\n    await middleware3();\n    console.log('middleware2 end');\n}\n\nfunction middleware3() {\n    console.log('middleware3 begin');\n    console.log('middleware3 end');\n}\n\nmiddleware1();\n// 执行结果\nmiddleware1 begin\nmiddleware2 begin\nmiddleware3 begin\nmiddleware3 end\nmiddleware2 end\nmiddleware1 end\n</code></pre>\n<p><code>compose()</code> 函数通过 Promise 将这个过程串联起来，从而返回单个中间件函数。</p>\n<h2>Context</h2>\n<p>Koa 中的 Context 模块封装了 request 与 response，代理了这两个对象的方法与属性。</p>\n<p>其中使用了 Tj 写的 <a href=\"https://github.com/tj/node-delegates\">node-delegates</a> 库，用于代理 context.request 与 context.response 上的方法与属性。</p>\n<pre><code class=\"language-js\">/**\n * Response delegation.\n */\n\ndelegate(proto, 'response')\n  .method('attachment')\n  .method('redirect')\n  .method('remove')\n  .method('vary')\n  .method('set')\n  .method('append')\n  .method('flushHeaders')\n  .access('status')\n  .access('message')\n  .access('body')\n  .access('length')\n  .access('type')\n  .access('lastModified')\n  .access('etag')\n  .getter('headerSent')\n  .getter('writable');\n  // ...\n</code></pre>\n<p>context 除了代理这两个模块之外，还包含了一个请求异常时的错误处理函数。</p>\n<p>在 application.js 的 <code>callback()</code>使用到这个函数。</p>\n<pre><code class=\"language-js\">const onerror = err => ctx.onerror(err);\nconst handleResponse = () => respond(ctx);\nonFinished(res, onerror);\nreturn fn(ctx).then(handleResponse).catch(onerror);\n</code></pre>\n<h3>Context#onerror</h3>\n<p><code>context.onerror(err)</code>首先对传入的 err 变量进行判断，当 err 为空时退出该函数，或者当 err 不为空且不为 Error 类型时抛出异常。</p>\n<pre><code class=\"language-js\"> if (null == err) return;\n\n if (!(err instanceof Error)) err = new Error(`non-error thrown: ${err}`);\n</code></pre>\n<p>接着触发 app 自身的 error 事件，将错误抛给 app。</p>\n<p>在此之前，设置 <code>headerSent</code>变量表示响应头是否发送，若响应头以发送，或者不可写（即无法在响应中添加错误信息等），则退出该函数。</p>\n<pre><code class=\"language-js\">let headerSent = false;\nif (this.headerSent || !this.writable) {\n  headerSent = err.headerSent = true;\n}\n\n// delegate\nthis.app.emit('error', err, this);\n\n// nothing we can do here other\n// than delegate to the app-level\n// handler and log.\nif (headerSent) {\n   return;\n}\n</code></pre>\n<p>因为发生了错误，所以必须将之前的中间设置的响应头信息清空。</p>\n<p>这里使用了 Node 提供的 <a href=\"https://nodejs.org/api/http.html#http_class_http_serverresponse\">http.ServerResponse</a> 类上的 <code>getHeaderNames()</code> 与 <code>removeHeader()</code> 方法。但<code>getHeaderNames()</code></p>\n<p>这个函数是在 Node.js 7.7 时加入的，所以当没有提供该方法时需要使用 <code>_header</code>来清空响应头。详情可见: <a href=\"https://github.com/nodejs/node/pull/10805\">Node.js #10805。</a></p>\n<pre><code class=\"language-js\">// first unset all headers\nif (typeof res.getHeaderNames === 'function') {\n  res.getHeaderNames().forEach(name => res.removeHeader(name));\n} else {\n  res._headers = {}; // Node &#x3C; 7.7\n}\n</code></pre>\n<p>清空之前的中间件设置的响应头之后，将响应头设置为 <code>err.headers</code>，并设置 Context-Type 与状态码。</p>\n<p>当错误码为 ENOENT 时，意味着找不到该资源，将状态码设置为 404；当没有状态码或状体啊码错误时默认设置为 500。</p>\n<pre><code class=\"language-js\">// then set those specified\nthis.set(err.headers);\n\n// force text/plain\nthis.type = 'text';\n\n// ENOENT support\nif ('ENOENT' == err.code) err.status = 404;\n\n// default to 500\nif ('number' != typeof err.status || !statuses[err.status]) err.status = 500;\n</code></pre>\n<p>最后当抛出的错误为自定义错误时，返回错误信息。</p>\n<p>Koa 使用 <a href=\"https://github.com/jshttp/http-errors\">http-errors</a> 创建错误对象，<code>expose</code> 属性表示是否像客户端暴露错误信息。</p>\n<pre><code class=\"language-js\">const code = statuses[err.status];\nconst msg = err.expose ? err.message : code;\nthis.status = err.status;\nthis.length = Buffer.byteLength(msg);\nthis.res.end(msg);\n</code></pre>\n<h2>Request</h2>\n<p>Request 模块封装了请求相关的属性以及方法。通过 application 中的 <code>createContext()</code> 方法，代理对应的 request 对象。</p>\n<pre><code class=\"language-js\">const request = context.request = Object.create(this.request);\n// ...\ncontext.req = request.req = response.req = req;\n// ...\nrequest.response = response;\n</code></pre>\n<p><code>request.req</code>为原生的请求对象，在 Request 模块中属性的获取都是通过 <code>ths.req</code> 来获取的（即 <code>request.req</code>）。</p>\n<h2>Response</h2>\n<p>Response 模块封装了响应相关的属性以及方法。与 request 相同，通过<code>createContext()</code> 方法代理对应的 response 对象。</p>\n<pre><code class=\"language-js\">const response = context.response = Object.create(this.response);\n// ...\ncontext.res = request.res = response.res = res;\n// ...\nresponse.request = request;\n</code></pre>","rawMarkdownBody":"\n## 源码结构\n\nKoa 的源码中主要为 `lib` 目录下的 `application.js`、`context.js`、`request.js` 与 `response.js` 文件\n\n<!--more-->\n\n```\n.\n├── AUTHORS\n├── CODE_OF_CONDUCT.md\n├── History.md\n├── LICENSE\n├── Makefile\n├── Readme.md\n├── benchmarks\n├── docs\n├── lib\n│   ├── application.js\n│   ├── context.js\n│   ├── request.js\n│   └── response.js\n├── package.json\n└── test\n```\n\n**application.js**: 框架入口，导出 Application 类，即使用时导入的 Koa 类\n\n**context.js**: context 对象的原型，代理 request 与 response 对象\n\n**request.js**:  request 对象的原型，提供请求相关的数据与操作\n\n**response.js**: response 对象的原型，提供响应相关的数据与操作\n\n## Application\n\napplication.js 是 Koa 框架的入口，导出 Application 类来用于创建 app 对象。\n\n```js\nconst Koa = require('koa'); // 导入 Koa, 即导入 Application 类\nconst app = new Koa(); // 创建 Application 类的实例\n```\n\nApplication 继承于 EventEmitter 类，使得 Koa 能够监听事件。\n\n## 构造函数\n\nApplication 类包含了以下属性：\n\n* **proxy**: 是否信任 proxy header 参数，默认为 false\n* **middleware**: 保存通过 `app.use(middleware)` 注册的中间件\n* **subdomainOffset**: 子域默认偏移量，默认为 2\n* **env**: 环境参数，默认为 NODE\\_ENV 或 'development'\n* **context**: context 模块，通过 `context.js` 创建\n* **request**: request 模块，通过 `request.js` 创建\n* **response**: response 模块，通过 `response.js` 创建\n\n## Application\\#listen\n\nKoa 通过 `app.listen(port)` 函数在某个端口启动服务。\n\nlisten 函数通过 http 模块开启服务：\n\n```js\n/**\n * Shorthand for:\n *\n *    http.createServer(app.callback()).listen(...)\n *\n * @param {Mixed} ...\n * @return {Server}\n * @api public\n */\n\nlisten(...args) {\n  debug('listen');\n  const server = http.createServer(this.callback());\n  return server.listen(...args);\n}\n```\n\n实际上 `app.listen()`为 `http.createServer(app.callback()).listen(...)`的速记写法。\n\n`http.createServer()`用于创建 Web 服务器，接受一个请求监听函数，并在得到请求时执行。\n\n`app.callback()`用于处理请求，合并中间件与创建请求上下文对象等。\n\n### Application\\#use\n\nKoa 通过 `app.use()`添加中间件，并将中间件储存在 `app.middleware`中。\n\n在执行 `app.callback()`时会将 `app.middleware` 中的中间件合并为一个函数。\n\n```js\n/**\n * Use the given middleware `fn`.\n *\n * Old-style middleware will be converted.\n *\n * @param {Function} fn\n * @return {Application} self\n * @api public\n */\n\nuse(fn) {\n  if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n  if (isGeneratorFunction(fn)) {\n    deprecate('Support for generators will be removed in v3. ' +\n              'See the documentation for examples of how to convert old middleware ' +\n              'https://github.com/koajs/koa/blob/master/docs/migration.md');\n    fn = convert(fn);\n  }\n  debug('use %s', fn._name || fn.name || '-');\n  this.middleware.push(fn);\n  return this;\n}\n```\n\nKoa1.x 版本使用 Generator Function 的方式写中间件，而 Koa2 改用 ES6 async/await。\n\n所以在 `use()` 函数中会判断是否为旧风格的中间件写法，并对旧风格写法的中间件进行转换（使用 [koa-convert](https://github.com/koajs/convert) 进行转换）。\n\n可以注意到这里 `use()` 函数返回了 this，这使得在添加中间件的时候能够链式调用。\n\n```js\napp\n  .use(function (ctx, next) {\n    // do some thing\n  })\n  .use(function (ctx, next) {\n    // do some thing\n  })\n  // ...\n```\n\n### Application\\#callback\n\n`app.callback()`负责合并中间件，创建请求上下文对象以及返回请求处理函数等。\n\n```js\n  /**\n   * Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public\n   */\n\n  callback() {\n    const fn = compose(this.middleware);\n\n    if (!this.listeners('error').length) this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n      res.statusCode = 404;\n      const ctx = this.createContext(req, res);\n      const onerror = err => ctx.onerror(err);\n      const handleResponse = () => respond(ctx);\n      onFinished(res, onerror);\n      return fn(ctx).then(handleResponse).catch(onerror);\n    };\n\n    return handleRequest;\n  }\n```\n\n通过 `compose` 函数（[koa-compose](https://github.com/koajs/compose)）合并 `app.middleware`中的所有中间件。[查看](/koa/compose.md)关于 koa-compose 的分析。\n\n`app.callback()` 函数最后返回一个请求处理函数 `handleRequest`。该函数即为`http.createServer` 接收的请求处理函数，在得到请求时执行。\n\n#### handleRequest\n\n`handleRequest`函数首先将响应状态码默认设置为 404，接着通过 `app.createContext()`创建请求的上下文对象。\n\n`onFinished(res, onerror)`通过第三方库 [on-finished](https://github.com/jshttp/on-finished) 监听 http response，当请求结束时执行回调。\n\n这里传入的回调是 `context.onerror(err)`，即当错误发生时才执行。\n\n最后返回 `fn(ctx).then(handleResponse).catch(onerror)`，即将所有中间件执行（传入请求上下文对象 ctx），之后执行响应处理函数（`app.respond(ctx)`），当抛出异常时同样使用 `cintext.onerror(err)`处理。\n\n#### createContext\n\napp.createContext\\(\\) 用来创建请求上下文对象，并代理 Koa 的 request 和 response 模块。\n\n```js\n/**\n * Initialize a new context.\n *\n * @api private\n */\n\ncreateContext(req, res) {\n  const context = Object.create(this.context);\n  const request = context.request = Object.create(this.request);\n  const response = context.response = Object.create(this.response);\n  context.app = request.app = response.app = this;\n  context.req = request.req = response.req = req;\n  context.res = request.res = response.res = res;\n  request.ctx = response.ctx = context;\n  request.response = response;\n  response.request = request;\n  context.originalUrl = request.originalUrl = req.url;\n  context.cookies = new Cookies(req, res, {\n    keys: this.keys,\n    secure: request.secure\n  });\n  request.ip = request.ips[0] || req.socket.remoteAddress || '';\n  context.accept = request.accept = accepts(req);\n  context.state = {};\n  return context;\n}\n```\n\n这里对请求都对应在上下文对象中添加对应的 cookies。\n\n#### respond\n\n`app.respond(ctx)` 函数，也就是 `app.createContext()`函数中的 `handleResponse`。在所有中间件执行完之后执行。\n\n在 koa 中可以通过设置 `ctx.respond = false`来跳过这个函数，但不推荐这样做。另外，当上下文对象不可写时也会退出该函数：\n\n```js\nif (false === ctx.respond) return;\n// ...\nif (!ctx.writable) return;\n```\n\n当返回的状态码表示没有响应主体时，将响应主体置空：\n\n```js\n// ignore body\nif (statuses.empty[code]) {\n  // strip headers\n  ctx.body = null;\n  return res.end();\n}\n```\n\n当请求方法为 HEAD 时，判断响应头是否发送以及响应主体是否为 JSON 格式，若满足则设置响应 Content-Length：\n\n```js\nif ('HEAD' == ctx.method) {\n  if (!res.headersSent && isJSON(body)) {\n    ctx.length = Buffer.byteLength(JSON.stringify(body));\n  }\n  return res.end();\n}\n```\n\n当返回的状态码表示有响应主体，但响应主体为空时，将响应主体设置为响应信息或状态码。并当响应头未发送时设置 Content-Type 与 Content-Length：\n\n```js\nif (null == body) {\n  body = ctx.message || String(code);\n  if (!res.headersSent) {\n    ctx.type = 'text';\n    ctx.length = Buffer.byteLength(body);\n  }\n  return res.end(body);\n}\n```\n\n最后，对不同的响应主体进行处理：\n\n```js\n// responses\nif (Buffer.isBuffer(body)) return res.end(body);\nif ('string' == typeof body) return res.end(body);\nif (body instanceof Stream) return body.pipe(res);\n\n// body: json\nbody = JSON.stringify(body);\nif (!res.headersSent) {\n  ctx.length = Buffer.byteLength(body);\n}\nres.end(body);\n```\n\n## Compose\n\n在 application.js 中，`callback()`函数通过 `koa-compose` 组合所有的中间件，组合成单个函数。\n\nkoa-compose  的实现很简单：\n\n```js\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n首先判断了传入得中间件参数是否为数组，并检查且数组的元素是否为函数，然后返回了一个将中间件组合起来的函数。\n\n重点关注返回的函数中的`dispatch(i)`函数，这个函数将获取第一个中间件，并在返回的 Promise 中执行。当中间件`await next()`时执行下一个中间件，即 `dispatch(i + 1)`。\n\n执行流程可以简单看作：\n\n```js\nasync function middleware1() {\n    console.log('middleware1 begin');\n    await middleware2();\n    console.log('middleware1 end');\n}\n\nasync function middleware2() {\n    console.log('middleware2 begin');\n    await middleware3();\n    console.log('middleware2 end');\n}\n\nfunction middleware3() {\n    console.log('middleware3 begin');\n    console.log('middleware3 end');\n}\n\nmiddleware1();\n// 执行结果\nmiddleware1 begin\nmiddleware2 begin\nmiddleware3 begin\nmiddleware3 end\nmiddleware2 end\nmiddleware1 end\n```\n\n`compose()` 函数通过 Promise 将这个过程串联起来，从而返回单个中间件函数。\n\n## Context\n\nKoa 中的 Context 模块封装了 request 与 response，代理了这两个对象的方法与属性。\n\n其中使用了 Tj 写的 [node-delegates](https://github.com/tj/node-delegates) 库，用于代理 context.request 与 context.response 上的方法与属性。\n\n```js\n/**\n * Response delegation.\n */\n\ndelegate(proto, 'response')\n  .method('attachment')\n  .method('redirect')\n  .method('remove')\n  .method('vary')\n  .method('set')\n  .method('append')\n  .method('flushHeaders')\n  .access('status')\n  .access('message')\n  .access('body')\n  .access('length')\n  .access('type')\n  .access('lastModified')\n  .access('etag')\n  .getter('headerSent')\n  .getter('writable');\n  // ...\n```\n\ncontext 除了代理这两个模块之外，还包含了一个请求异常时的错误处理函数。\n\n在 application.js 的 `callback()`使用到这个函数。\n\n```js\nconst onerror = err => ctx.onerror(err);\nconst handleResponse = () => respond(ctx);\nonFinished(res, onerror);\nreturn fn(ctx).then(handleResponse).catch(onerror);\n```\n\n### Context\\#onerror\n\n`context.onerror(err)`首先对传入的 err 变量进行判断，当 err 为空时退出该函数，或者当 err 不为空且不为 Error 类型时抛出异常。\n\n```js\n if (null == err) return;\n\n if (!(err instanceof Error)) err = new Error(`non-error thrown: ${err}`);\n```\n\n接着触发 app 自身的 error 事件，将错误抛给 app。\n\n在此之前，设置 `headerSent`变量表示响应头是否发送，若响应头以发送，或者不可写（即无法在响应中添加错误信息等），则退出该函数。\n\n```js\nlet headerSent = false;\nif (this.headerSent || !this.writable) {\n  headerSent = err.headerSent = true;\n}\n\n// delegate\nthis.app.emit('error', err, this);\n\n// nothing we can do here other\n// than delegate to the app-level\n// handler and log.\nif (headerSent) {\n   return;\n}\n```\n\n因为发生了错误，所以必须将之前的中间设置的响应头信息清空。\n\n这里使用了 Node 提供的 [http.ServerResponse](https://nodejs.org/api/http.html#http_class_http_serverresponse) 类上的 `getHeaderNames()` 与 `removeHeader()` 方法。但`getHeaderNames()`\n\n这个函数是在 Node.js 7.7 时加入的，所以当没有提供该方法时需要使用 `_header`来清空响应头。详情可见: [Node.js \\#10805。](https://github.com/nodejs/node/pull/10805)\n\n```js\n// first unset all headers\nif (typeof res.getHeaderNames === 'function') {\n  res.getHeaderNames().forEach(name => res.removeHeader(name));\n} else {\n  res._headers = {}; // Node < 7.7\n}\n```\n\n清空之前的中间件设置的响应头之后，将响应头设置为 `err.headers`，并设置 Context-Type 与状态码。\n\n当错误码为 ENOENT 时，意味着找不到该资源，将状态码设置为 404；当没有状态码或状体啊码错误时默认设置为 500。\n\n```js\n// then set those specified\nthis.set(err.headers);\n\n// force text/plain\nthis.type = 'text';\n\n// ENOENT support\nif ('ENOENT' == err.code) err.status = 404;\n\n// default to 500\nif ('number' != typeof err.status || !statuses[err.status]) err.status = 500;\n```\n\n最后当抛出的错误为自定义错误时，返回错误信息。\n\nKoa 使用 [http-errors](https://github.com/jshttp/http-errors) 创建错误对象，`expose` 属性表示是否像客户端暴露错误信息。\n\n```js\nconst code = statuses[err.status];\nconst msg = err.expose ? err.message : code;\nthis.status = err.status;\nthis.length = Buffer.byteLength(msg);\nthis.res.end(msg);\n```\n\n## Request\n\nRequest 模块封装了请求相关的属性以及方法。通过 application 中的 `createContext()` 方法，代理对应的 request 对象。\n\n```js\nconst request = context.request = Object.create(this.request);\n// ...\ncontext.req = request.req = response.req = req;\n// ...\nrequest.response = response;\n```\n\n`request.req`为原生的请求对象，在 Request 模块中属性的获取都是通过 `ths.req` 来获取的（即 `request.req`）。\n\n## Response\n\nResponse 模块封装了响应相关的属性以及方法。与 request 相同，通过`createContext()` 方法代理对应的 response 对象。\n\n```js\nconst response = context.response = Object.create(this.response);\n// ...\ncontext.res = request.res = response.res = res;\n// ...\nresponse.request = request;\n```\n","frontmatter":{"title":"Koa2 源码分析","date":"2017年5月17日","tags":["Koa","Node.js"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/koa2-analysis/"}}}